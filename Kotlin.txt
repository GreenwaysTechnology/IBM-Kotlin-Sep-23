				 Kotlin

Software setup:
1.JDK 17
2.Intellij Idea - community edition.
.....................................................................................

What is Kotlin?
  Kotlin is one of the programming language.
  Kotlin is programming language for "JVM".

What is JVM?
  Java Virtual Machine, which is the process used to run java applications.
  JVM is abstract computer which solves the problem of Platform Independant.

What is Java?
   According to Sun Micro System, Java is  technology.

What is technology?
   Technology means solving the Pratical real time Problems.

Why Java Technology created?
   Since java is technology, it must have created for solving some problems.

Java was created to solve the problem of "Platform Specific Application Development"
in other words, java was created to solve the problem of "Platform Independant".
Before Java apps were used to build using c and c++  programming languages.

Java Technology brought many things.

Java means lot 

1.Java Programming language
2.tools 
    compilers,debuggers,libs,apis
3.Runtime- JRE
4.JDK

What is Java Programming language?
  Java Programming language was created based on "c++,Small Talk,C" like languages.

Java features
1.Java was created based on the style called "Object oriented"
2.Java removed pointers 
3.java added lot of new features automatic memory management
4.Java introduced  Platform independant Threading features
etc....

How java achives the platform independant?
 JVM is abstract machine through which we can achive platform independant features.

After publishing java, Sun Micro systems wanted to improve java technology for that who formed non profitable organziation who standarize the java technology.

JCP - Java Community Processs:
..............................
JCP is organization who standards java technology even today.

After SUN Micro systems, Java technology was acquired by "Oracle".

Classification of Java Technology:
..................................
JCP classifies the Java into three Major Editions

1.JAVA SE - Standard Edition
2.JAVA EE - Enterprise Edition
3.JAVA ME - Micro Edition
.....................................................................................
JCP has published so many specifications.
Java Versions are released by JCP only - java 11, java 12,java 17,java 18,java 20...
.....................................................................................
			JSR 223 :Scripting For the Java Platform
....................................................................................
JSR 223 Spec was released on June-10-2023.

Why this spec?
 Before JSR 223, Only one programming langugage was there for JVM-Java programming language.

This spec aim was to introduce new languages for JVM. - Poly Glot languages for java platform.
.....................................................................................
		  Birth of new Programming languages for JVM
.....................................................................................

Based on this spec , the first language other than java pl was created for JVM - Groovy Programming language.
.....................................................................................

Top JVM languages today
 
1.Java
2.Kotlin
3.Scala
4.Groovy
5.Clojure
6.Fantom
7.Ceylon
8.Jython
9.JRuby
10.Frege
11.Xtend
12.Golo
13.Concurnaas
14.Yeti

	Java PL  Groovy Scala Kotlin Closure Any
       ..........................................
			|
		    Byte Code
			|
		       JVM

All programming langagues compiles their code into byte code which is platform independant code.
.....................................................................................
		 
How the programming languages differs each other?
  
   The every programming languages follows different programming styles.

Programming styles:

There are numerous programming styles are available.

1.Object oriented
2.Functional Programming
3.Procedural Programming
4.Rule Based Programming
etc........

if i want to create new programming language, first i need to select any one of the programming style or can combine many styles.

A language can follow one style or many styles

if a language follows one style, that language is called "single style language"
if a language follows many styles , that language is called "Hyibrid style language".

eg:
 C language follows only one style- Procedural Style, so that we can call c language is procedural language.

 C++ language follows only one style- Object oriented Style, so that we call C++ is object oriented language.

 Java language followed initally when it was created one style - Object oriented Style - Java was Object orinted language.

 Later Java (Java 8) introduced feature called "Functional Programming", after that Java became hybrid language- Java is object oriented,functional style programming language.
.....................................................................................
Groovy:
 Groovy was created functional and object oriented programming languages.
 Groovy is the first functional programming language for JVM.

Scala
  Object oriented and functional style language

Kotlin:
  Kotlin is Object oriented, functional style programming languge
.....................................................................................
		 Kotlin is dervied from "Scala and Groovy"
.....................................................................................
		 Language is classififed based on Data types
....................................................................................

1.Strongly Typed /Static Typed 
   The type of variable is decided during compile
 
int a =10;
a="Hello"


2.Weakly typed or Dynamic typed 
  The type of variable is decided during runtime 
  var a=10;
  a="hello"
The type of a is not verified during compile time.

The java is strongly typed
The javascript is dynamic typed

          "Kotlin is dynamic , strongly Typed language"
....................................................................................
		Language is classififed based on Program style
....................................................................................

Programming language is classified based on two category.

GPL - General Purpose Programming language.
    language is used to build any type of apps using "imperative methodology"

DSL  -Domain Specific language
   Language is used to build specific type of apps using "Declarative methodlogy"

Kotlin is kind of GPL and DSL language using "declarative methodlogy"

DSL Code is more declarative

   move left and move right - DSL code
   find Sqrt of 10 - DSL code
   take 1 pile every day at moring 7 am - DSL Code.

Imperative code/Programming:
...........................
 Any program there is two aspects
   ->Infra structure code
   ->Application logic.
What is it? How is it?

Declarative Programming:
  Focus application logic
  more readable
  less boiler plate
  less code code maintaiance because less code
eg:
  list.sort.filter.map.find.flaten
.....................................................................................
   "Kotlin helps to build more declarative DSL ,functional , Object oriented apps"

Kotlin language is highly multi purpose programming language
 ->To build mobile apps->Multiplatform mobile apps - android and IOS apps
 ->To build server side apps- Microservices, RESTFull apis, Dynamic web apps
 ->To build Platform natives apps like C++.


Learning Path:
..............
1.language fundamentals
2.Object oriented Programming in Kotlin
3.Functional Programming in Kotlin
4.Exception Handling
5.Data Structures in Kotlin
6.Cocurrency - Co-Routines
7.Async programming /Non Blockings
8.How to build DSL
9.How to use In Mobile Development.
...................................................................................
				 Lanaguage fundamentals
....................................................................................
We are going to build console based kotlin apps

Steps to create Kotlin Project.

You can use any build tool to create kotlin Project

Every kotlin programm is saved with "fileName.kt"


Unlike Java programs , Kotlin programs need not be started with classes, you can start with main method(function).

Kotlin Programming style

1.file based or script based
2.class based - oo style

HelloWorld.kt

fun main(){
    println("Hello Kotlin")
}

In Kotlin:

=>fun is used to declare a function
=>The main function is where your program starts from
=>The body of a function is written within curly braces {}
=>println and print functions print the their arguments to standard output.
=>In Koltin ";" is optional.
.....................................................................................
Kotlin Program Structure:

Programs are collection of Instructions.

Instructions = (Information + How the information is stored,processed,retrived)
information is nothing but data.

We need to store data in memory adress, in order to store we need to handle that memory address.

Variables:
 It is handler to store data.

Data 
 -Simple data- atomic data -Primitive data
 eg: 10,char,true or false, decimals 10.45

Any Data can be broken into smaller unit.

Numbers
  1.whole numbers
    - binary,oct,hexa 
  2.Decimal numbers
     -Float,Double

Abstract Data types:
  In the begining of programming only basic types were used by languages like numbers, characters.

How to create our own Data type/Type Custom?
   Custom Types

Struct,Union  - C implementation of Abstract Data types...

Any Abstract/Custom type is built on top of core types.

eg:
  struct Employee = {numbers,characters}
 
Here Employee is Type called custom type/abstract type

After struct and union in c language, new type construct introduced called "class"

 class Employee {
   numbers
   characters
 }

Type -Data Types
 -Primitives
 -Complex/Custom/Reference types


Variables:
  -Holder to hold any type

Literals:
  -values
    ->Primitive Literals
    ->Complex Literals


In Kotlin Types are dervided from java language.

Java Primtives:
1.Numbers
  -byte,short,int,long
  -float,double
2.char
3.boolean

	"In Kotlin we cant use primtive types directly, rather we have to use always
	 Reference/complex types only"


	In Kotlin every thing is object, Every object type is reference Type.
.....................................................................................

Varibles:

  Variables are introduced using two keywords

1.var keyword
2.val keyword

Syntax:
  var | val | withoutAnyKeyword = variableName:Type = literal(value)


fun main() {
    println("Variables and Values")
    //int a=10; java syntax
    var b: Byte = 90 // size is 1 byte
    var s: Short = 100 //size is 2 bytes
    var i: Int = 100 // size is byte 4 bytes
    var lng: Long = 92232323 //size is 8 bytes
    println("Byte "+b)
    println("Short " + s)
    println("Int " + i)
    println("Long " + lng)
    
}

Strings:
fun main() {
    var firtName: String = "Subramanian"
    var lastName: String = "Murugan"
    println("Name " + firtName + lastName)
}

Float and Double:
fun main() {
    var price: Float = 100.9f
    var totalPrice: Double = price * 100.89
    println("Price and Total Price " + price + " ," + totalPrice)
}

Booleans:

fun main(){
    var isEnabled:Boolean = true
    println("IsEnabled " + isEnabled)
}
.....................................................................................
			 Type Inference
.....................................................................................

The type of the variable is "infered" automatically based on the literals.

Explicit type declaration:

var a:Int =10

Type inference Declaration

var a=10

 Here no type is mentioned explicity : type inference.

fun main() {
    var a = 10
    println("A " + a )
    //a="hello" ; it is invalid
    var price =10.4
    println("Price " + price )
    //price =19.4f it is invalid
    var status = true
    println("Status " + status)

}

Kotlin language is "strongly typed/static type language, even though language looks like without type, but type is infered
....................................................................................
				Strings
...................................................................................

String is collection of 16 bit unicode characters
String is object , so that is reference type
Strings are declared using "" or """

Strings are concated with + =>> Traditional style.

Kotlin supports the concept called "String Templates" - String interpolation.

 "$Variable" or "${Variable}

When ever you concat strings use always the above syntax.

fun main() {
    var firstName = "Subramanian"
    var lastName = "Murugan"
    println("Name " + firstName + lastName) //traditional way
    println("Name is $firstName $lastName")
    println("Name is ${firstName} ${lastName}")
}
.....................................................................................
			Mutli Line Strings
.....................................................................................

Java style:

fun main() {
    var doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body> </body></html>"
    print(doc)
}

Kotlin Style:
"""
fun main() {
    var title = "My Page"
    var doc = """
           <html>
            <head>
              <title>${title} </title>
            </head>
            <body>
              <h1>Hello</h1>
            </body>
            </html>
        """
    print(doc)
}
.....................................................................................			    Static Typed language or Dynamic Typed Language



Static Type:
 
int a =10
a=100 // valid
a="hello" // it is invalid: Compile time error


Dynamic Typed:

Javascript :

let a =10; // valid - number
a="Hello" // valid - string
a=true //valid -boolean

In Groovy: 
    Groovy is dynamic Typed language
def  a =10 // valid
a="Hello"  //valid
a =true //valid

Kotlin is Language "Strongly typed or Static Typed" language even though language looks like without type, but the type is infered.

fun main() {
    //def  a =10 :Groovy
    var a = 10 // here type inference is enabled
   // a="Hello" //Kotlin: Type mismatch: inferred type is String but Int was expected
}
....................................................................................
			Basic Operators
.....................................................................................

All Operators supported by Java language Supported by Kotlin as well.

Types of Operators:
......................

1.Arthimetic Operators
2.Conditional Operators
3.Logical Operators

Arthimetic Opertors:
....................
fun main() {
    var a = 10;
    var b = 20
    //add
    var c = a + b
    println("Add Result $c")
    c = a - b
    println("Substract Result $c")
    c = a * b
    println("Multiplication Result $c")
    c = a / b
    println("Division Result $c")
    c = a % b
    println("Mod Result $c")
    //Augmented Operators
    var counter = 1
    counter += 1
    println("Counter $counter")


}

Logical Operators:
fun main() {
    var isValid = true
    var isEnabled = false
    //&&
    var result = isValid && isEnabled
    println("And Operator Result $result")

    result = isValid || isEnabled
    println("And Operator Result $result")
}


Comparsional operators
fun main() {
    var x = 10
    var y = 20
    var isEqual = x == y
    println("Is Equal $isEqual")
    var str = "hello"
    var strCp = str
    var refEqual = str == strCp
    println("Reference Equal $refEqual")

    //Less than and greater than
    var isBig = 100 > 200
    println("IsBig $isBig")
}
.....................................................................................
			Conditional Flow
....................................................................................

Conditions: if

In Kotlin, "if" is an Expression.
It can return a value like functions.
So In Kotlin there is no need for tenary operator :There is no tenary operator 
(Condition ? truthy:fasly) - Similar construct if expression provides
(Condition ? then:else)

IF:
fun main() {
    var a = 100
    var b = 20
    var max = a
    //Traditional way
    if (a < b) {
        max = b
    }
    println("Max $max")
    //Kotlin Expression Style
    if (a < b) max = b // Here we return max variable : looks like function return value
    println("Max $max")

}

IF...ELSE:
.........
fun main() {
    //IF ELSE
    var a = 100
    var b = 10
    var max = a
    //traditional:java style
    if (a > b) {
        max = a
    } else {
        max = b
    }
    println("MAX $max")

    //Kotlin Expression style
    max = if (a > b) a else b
    println("MAX $max")

    var isValid = true

    var status = if (isValid) "Valid" else "Invalid"
    println("Status $status")

}

IF ....ELSE..IF
fun main() {
    var a = 100
    var b = 2
    var maxLimit = 1
    var maxOrLimit = if (maxLimit > a) maxLimit else if (a > b) a else b
    println("maxorMaxLimit is $maxOrLimit")
}

if condition and block of code:
.................................
fun main() {
    var isEnabled = false
    var res = if (isEnabled) "Enabled" else "Disabled"
    println("Result is $res")

    //block of code
    res = if (isEnabled) {
        println("Some code")
        println("some even if more code")
        //must return value
        "Enabled"
    } else {
        println("some else code")
        println("some even extra else code")
        "Disabled"
    }
    println("Result is $res")
}
.....................................................................................
				When Expression
.....................................................................................

When defines a conditional expression with mulitple branches. It is similar to the "switch" statement in c like languages

Syntax:

when(expression) {
   value 1 -> code 
   value 2 -> code 
   value N -> code
   else -> {
      code
   }
}
When "matches" its arguments against all branches sequentially until some branch condition is satisfied.

When can be used either as "expression" or as a "statement".

if it is used as an expression, the value of the first matching branch becomes the value of the overall expression.

if it is used as statement,the values of individual branches are ignored.

Just like with "if", each branch can be a block, and its value is the value of the last expression in the block.

The else branch is evaluated if none of the other branch conditions are satisifed.

if "when" is used as an expression, the else branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions.


Simple When:

Statement Based Syntax:
........................

fun main() {
    var x = 1
    when (x) {
        1 -> println("X is 1")
        2 -> println("X is two")
        10 -> println("X is 10")
        else -> println("No Match Found")
    }
}
....
One block can be used to satisfy multiple expressions.

fun main() {
    var y = 100
    when (y) {
        0, 1, 2, 3, 4, 5, 6, 7 -> println("0 to 7 met")
        8, 9, 10 -> println("8 to 10 met")
        else -> println("No Match Found")
    }
}

I want to write expression to match like

0 to 100
101 to 1000
1001 to 10000

There is an operator called "range" operator 

Range Operator:

1..100 - Numerber Range
a..z - Alphabet Range
A..Z - Alphabet Range

Simple Range: 
fun main() {
    //Type of numbers wouldbe IntRange
    var numbers = 1..10
    for (num in numbers) {
        println("num $num")
    }
    var alphabets = 'a'..'z'
    for (letter in alphabets) {
        println("letter $letter")
    }
}

Note: Advanced Range operations to be discussed later.

fun main() {
    var x = 600
    when (x) {
        in 1..100 -> println("X falls in range of 1 to 100")
        in 101..1000 -> println("X falls in range of 101 to 1000")
        else -> {
            println("X does not fall under the range")
        }
    }
}
.....................................................................................
When is used as "Statement":

  var x = 1
    when (x) {
        1 -> println("X is 1")
        2 -> println("X is two")
        10 -> println("X is 10")
        else -> println("No Match Found")
    }

When is used as "Expression":
............................

var result = when (expression) { 
     value1 -> "Return"
     value2 ->  "Return"
     else -> "Return"
}
fun main() {

    //Expression based
    var isLoggedIn = false
    var status = when (isLoggedIn) {
        true -> "Logged In"
        false -> "Not Logged In"
    }
    println("Status $status")
  
}
.....................................................................................
When with without arg:
.....................
fun main() {
    var num = 3
    var isEvenOrOdd = when {
        num % 2 == 0 -> "Even"
        num % 2 != 0 -> "Odd"
        else -> "No Match Found"
    }
    println("Result is $isEvenOrOdd")
}
....................................................................................
				Loops
...................................................................................

1.for loop
2.range 
3.while
4.do..while

1.For loop:
............

The for loop iterates through anything that provides iterator.
This is eq to C#, or Iterators in java.

Syntax:
 for(item in collection) statement
 
The body of for can be a block also.
  for(item:Type in collection){
    //block
  }
 
eg:

fun main(){
    for(item in 1..100){
        print("${item}, ")
    }
}

Ranges:
fun main() {
    //simple range
    for (i in 1..10) {
        print(i)
    }
    println("\n")
    //Reverse order
    for (j in 10 downTo  1) {
        print(j)
    }
    //increment by 2
    for(counter in 1..100 step 2) println(counter)

    //until
    for(counter in 5 until 10) println(counter)
}

While and do while remain same like c/c++/java 
.....................................................................................	
				Functions
....................................................................................

What is function?
  The term function is derived from the mathmetics.
  The function represents unit of Execution.
  The Function is building block of computer system itself

Types of functions with respect to declaration and execution
1.Passive function
2.Active function

Every Program is running on Runtime which itself is another program.

Every java program is running on JVM Which is another Program.

JVM is written in C language.

According to OS, JVM is just process.

Every Process has three segments(memory Area)

1.Heap
2.Stack
3.Program Data/Method Area

Program data/Method Area:
........................
It is memory segement where all "Passive Instructions" of the Program stored.
All functions are stored/initalized in this area.
All Static variables are initalized inside method area.
All literals(values)  are initalized inside constant pool of method area.

...................................................................................
			 Runtime representation of functions
...................................................................................

In Programs runtime Representation means, which should be accessed by CPU.
If any instructions needs to be accessed by CPU means, it should be available inside Main Memory.

Every function must be allocated on RAM, So that it can be accessed by CPU...

Declaration 
fun main(){ }

Function declaration means which is avilable as part of Method area

Execution: Allocating Memory on RAM
main() --->We have to allocate memory on RAM ----?

When the function is called, that function is pushed into "Stack".

Stack is simple Last In First Out Datastructure.

Once the function gets pushed into Stack,the Runtime allocates memory on RAM.

Stack Framework:
 Stack Framework is nothing but , the runtime representation of every function.
 Stack Framework contains instructions like local variables,Stack Begining  pointer,Return address from where the function gets called.
  
Stack Frames are executed sequentially by default.

hello()--->pushed into stack---creates Frame---running frame----frame returns--frame is removed from main Memory.

.....................................................................................
			Kotlin functions
...................................................................................

Kotlin supports different types of functions

1.normal function
2.infix function
3.local function
4.member function
5.Tail Recursive function
6.inline functions
7.suspend functions
8.operator functions
9.lambda functions

1.Normal Functions
 ->How to declare
 ->How to invoke
 ->Args and Parameters
 ->Return values and types
 ->Types and Parameters

Every kotlin programs begins with main function, which is called by runtime.


Basic Function Declaration:
fun main() {
    println("main function starts")
    hello()
    println("main function ends")
}

//function declaration
fun hello() {
    println("hello")
}

Function with some kind of Logic:
.................................
//function declarations
fun add() {
    var a = 10
    var b = 20
    var c = a + b
    println("C $c")
}

fun multiply() {
    var a = 10
    var b = 20
    var c = a * b
    println("C $c")
}

fun main() {
    add()
    multiply()
}
.....................................................................................
			Functions args and parameters
.....................................................................................

Args are place holders which hold values(literals)
Parameters are values/literals which to be passed to the function.

Simple Args and Parameters:
...........................

//args
//message is argument
fun sayHello(message: String) {
    print(message)
}

fun main() {
    //Hello is parameter
    sayHello("Hello")
}


Function args and params with Logic;
....................................
fun add(a: Int, b: Int) {
    var c = a + b
    println("Add Result is $c")
}

fun multiply(a: Int, b: Int) {
    var c = a * b
    println("Multiply Result $c")
}

fun main() {
    add(10, 10)
    multiply(10, 10)
}

..................................................................................
			Advanced Parameters and Args - Default Args
................................................................................

Use case: passing all Parameters to the function
 Note: by default you cant miss any parameters

fun format(
    str: String,
    normalizeCast: Boolean,
    upperCaseFirstLetter: Boolean,
    wordSeparator: Char
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    format("hello", true, false, ',')
}

Here
 format("hello", true, false, ',') you are passing all parameters

....

Default Args:

//Defalut args
fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    format("hello", true, false, ',')
    format("hai")
    format()
}
.....................................................................................
			 Named Paremeters
..................................................................................

By default , Parameters are passed based on Positions called "Positional Parameters"

fun add(a:Int,b:Int){

}
here you have to pass parameters based on postions like "a" must be passed in first and "b" must be passed second

add(10,20) (a,b)

In Kotlin you can change the positions of parameters called "Named Parameters".

fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

}
Here i want to pass only word separator , the rest of the values should be default one.
//Defalut args
fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    //Positional Parameters
    format("hello", true, false, ',')
    format("hai")
    format()

    //Named parameters
    format(wordSeparator = ':')
    format(str = "How are you", upperCaseFirstLetter = true, wordSeparator = ';')
}
....................................................................................
			   How to return values from the function
....................................................................................

In Kotlin function returns Object.
if function does not return any thing, It returns by default One Object called "Unit"
Unit is Type with only one Value -Unit.
Unit value does not have to be returned explicitly.

Unit:

fun doStuff(): Unit {
    println("This function does not return any thing")
}

fun main() {
    var res = doStuff()
    println(res)
}

Other Return Types: Int,String,Boolean,Anything....


fun calculate(a: Int = 0, b: Int = 0): Int {
    return a + b
}

fun sayMyName(name: String = "Default Name"): String {
    return name
}

fun main() {
    var res = calculate(b = 10, a = 30)
    println("Calcualte Result $res")
    var name = sayMyName(name = "Subramanian")
    println("Name $name")
}
....................................................................................
			  Single-Expression Functions
.....................................................................................

When a function returns a single expression, the curly braces can be omitted and the body is specified after = symbol.

Normal Function:
fun sum(a: Int = 0, b: Int = 0): Int {
    return a * b
}

fun main() {
    println(sum(a = 90, b = 89))
}

/**
 * Normal function
fun sum(a: Int = 0, b: Int = 0): Int {
return a * b
}
 **/
//Single Expression Function
//Here we can omit curly braces and return statement.
fun sum(a: Int = 0, b: Int = 0): Int = a * b
fun getStock(value: Double): Double = value

//Here even we can omit return Type: Type Inference is enabled
fun double(x: Int) = x * 2
fun main() {
    println(sum(a = 90, b = 89))
    println(getStock(value = 10.89))
    println(double(x = 10))
}

Note:
Explicit Return types

1.Functions with block body must always specify return types explicitly,unless it's intended for them to return "Unit", in which case specificing the return type is Optional.

2.Kotlin does not infer return types for functions with block bodies because such functions may have complex control flow in the body, and the return type will be non obvious to the reader.
....................................................................................
				Null
....................................................................................
What is null?
  Null itself is value, Its type is Object.
  Null itslef is object.

History Of Null:
  In computing, a null pointer or null reference is a value saved for indicating that the pointer or reference does not refer to a valid object(value).

In 2009, Tony Hoare stated[15] that he invented the null reference in 1965 as part of the ALGOL W language. In that 2009 reference Hoare describes his invention as a "billion-dollar mistake":

reference: https://en.wikipedia.org/wiki/Null_pointer
.....................................................................................
			How to handle Null?

"Null" Reference is unavoidable in any Object Oriented Systems like c++,java,C#,Kotlin etc...

Handling null is more challange

How to handle null very safely?

Kotlin like languages handles null very effieciently without crashing the system with minimual , declarative code.

Kotlin handles null positively, if there is null, we can give alernate values.

How null is handled in java?
 In java, the methods,properties  access are verified during compile time.
 Invocations are verified during runtime only.
 if there is any null reference, jvm throws error during runtime.
 null cant be verified during compile time.


public class NullDemo {
    public static void main(String[] args) {
        String str = null;
        System.out.println(str.length());
    }
}
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "str" is null
	at NullDemo.main(NullDemo.java:5)

In Kotlin "null" is verified during "Compile" time,So that Your code will be more safer during Development.
Most of the null reference bugs can be identified
.....................................................................................

In java null is handled

A a =null

if(a!=null){ 
   do
}else{ 
  dont do
}

public class NullDemo {
    public static void main(String[] args) {
        String str = null;
        if (str != null) {
            System.out.println(str.length());
        } else {
            System.out.println("There is no object");
        }
    }
}

Kotlin and Null:
..................

1.Kotlin variables never allows null by default.

fun main(){
    var message:String =null
}
This code cause compile time error
 "Null can not be a value of a non-null type String"

fun main(){
    var message:String=""
    message = null 
}
This code also causes error.

Sometimes we cant avoid having null values.
How does we declare "null" in Kotlin?

You can declare variable "nullable" - variable can have null.

Synatax:
  var variableName:Type? = null

Eg:
fun main() {
    //var message:String=""
    // message = null
    var message: String? = null
    println(message)
}
.....................................................................................
		 What if I access any property on null Reference
....................................................................................

fun main() {
    var message: String? = null
    println(message.length)
}
You will compile time error if you access any property on "null" object.

"Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?"

Ways to Handle null Reference
..............................

1.Java Style : using if and notNull 
fun main() {
    var message: String? = null
    //println(message.length)
    //message="hello"
    //way 1: java style
    if (message != null) {
        println("Message Size is ${message.length}")
    } else {
        println("Message Size is having null value")
    }
}

2.Kotlin Style: Using there is operator "Safe Navigation Operator"
?. - SafeNavigation Operator.

var message:String? = null
println("Message Size Using Safe Navigation Opertor ${message?.length}")

if the variable is having null reference, The output would be "null"  
if the variable is having value, The output would be "value"

fun main() {
    var message: String? = null
    //println(message.length)
    //message="hello"
    //way 1: java style
    if (message != null) {
        println("Message Size is ${message.length}")
    } else {
        println("Message Size is having null value")
    }
    //Way 2: Kotlin Sytle : Using SafeNavgiation Operator
    println("Message Size Using Safe Navigation Opertor ${message?.length}")

}
output:
Message Size is having null value
Message Size Using Safe Navigation Opertor null

3.Kotlin Sytle:Using Elvis Operator
  If there is null in output, it would be replaced with some default value, that means some meaningfull default values

var result = variableName?.property ?:defaultValue

fun main() {
    var message: String? = null
    //Way 3:Kotlin Style: Using Elvis Operator
    var length = message?.length ?: 0
    println("Message Size Using Elvis Operator ${length}")

}
output:
Message Size Using Elvis Operator 0

4.Kotlin Style: Producing RuntimeException using NotNull Assertion Operator(!!)

  For Some Reasons, if you want "RuntimeException" to be thrown by the code
  How to throw RuntimeException.
  
Syntax:
 Variable!!.Property

fun main() {
    var message: String? = null
    //Way 4: Kotlin Style:Using Not Null Assertion Operator(!!)
    println("Message Size using Not Null Assertion Operator ${message!!.length}")

}
output:
Exception in thread "main" java.lang.NullPointerException
	at KotlinNullAccessKt.main(KotlinNullAccess.kt:19)
	at KotlinNullAccessKt.main(KotlinNullAccess.kt)


Safe Cast and Collections and Null : To be discussed later.
.................................................................................
				Functions,Null and Nullable
...................................................................................

Parameters and Null:


fun save(name: String? = "", city: String? = "", age: Int? = 1) {
    println("${name?.uppercase() ?: "Name".uppercase()} ${city?.uppercase() ?: "City".uppercase()} ${age ?: 1}")
}

fun main() {
    save(name = "Subramanian", city = "Coimbatore", age = 43)
    save(name = null, city = null, age = null)
}

Return Type and Null:
fun find(): String? {
    //return "find";
    return null
}


fun main() {
    println(find() ?: "empty")
}
.....................................................................................
				Functional Programming
.....................................................................................

What is Functional Programming?
  Functional Programming is one of the programming style for building apps.

History of Functional Programming:
..................................

Functional Programming principles and patterns implemented from the "Mathmetics" called "Lambda Calculs".

Lambda calculus (also written as Î»-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.

It is a universal model of computation that can be used to simulate any Turing machine.

It was introduced by the mathematician Alonozo Church in the 1930s as part of his research into the foundations of Mathmetics.

"Turning Machine"  is abstract computer which talks about how to "mutate state" / "Manipulate state".

What is meaning of Function according to "Lambda Calculs"?

  Function means "Unit of Computation" - Having expressions and variables and its values

f = {
  c = a + b
}

Functional Programming is the implementation of "Lambda Calculs" theorems...

The languages which implements "lambda Calculs" We call "functional programming language".

The first functional Programming language introduced in 1950's 
=>Lisp - First Appeared in 1960.

Based on Lisp language many languages were created

Most popular languages today
1.java script
2.Kotlin,scala,java 8
etc...

Principles of Functional Programming(Lambda Calculs):
.....................................................

1.Pure functions
  1.1.Side Effects,Immutability
2.Functions are first Class citizens 
  2.1.Higher order functions
3.Referential Transparency
4.Recursive functions rather than loops

All priniciples may not be used in all languages.

if a language implements all principles "The language is called "pure functional" Programming language

if a language does not implement all principles The language is called "functional style" Programming language


		"Kotlin is functional style language"


Kotlin functional programming implementations:

1.Function is first class citizens:
....................................

 Firt class means "special"

 -> Functions are passed around (in,out)
  
 This means the language supports passing function as arguments to other functions 
   -In
 Returning functions from other functions as "values"
  -Out

 Assigning functions into variables or stroing them inside data structures.
 
var a:Int =100
 
 a- is variable
 Int is data type
 100 is literal

Similar to 100 we can assign or treat functions..

According to functional Programming "function is literal /value" like int,double,string.

var variableName = fun myFun(){}

 "Kotlin functions are first class citizens, which means that they can be stored into variables, passed inside ds, as parameter, return them from other functions".

Higher Order Functions:
.......................
	First class functions are necessity for the functional programming style,in which the use of higher order functions is a standard practice.

In Mathmetics and Computer Science, a higher order function is a function that does the following things

1.takes one or more functions as arg
2.returns a function as its result.

Can i say this function is higher order fun?

fun map(){

}
 No, Because  it does not follow the thumb rule of higher order functions.
.....................................................................................
			Kotlin and functional programming implementations
.....................................................................................

Since Kotlin Static typed language, We need to tell the "Type of Itself"

fun map(FunctionType){

}

In kotlin , every thing is Object, FunctionType itself is Object behind the Scene
...................................................................................
			 Kotlin Functions types
...................................................................................

1.(T)->T
 eg:
  (Int)->Int
  (Int)->String
2.(T1,T2)->T3
  (Int,Int)->Int
  (Int,Int)->String
3.(T)->Unit
  (T)->Unit
  ()->Unt

fun map((T)->T) {

}
fun map((T1,T2)->T3) {

}
fun map((T)->Unit) {

}
Rules:
1.All Function types have a parenthesized type list and return type.
  (A,B)->c

2.Function type can Optionally have an additional "Receiver" Type,
  Which is represented a dot in the notation.
 
   "ReceiverObject".(B,C)->D
eg
    A.(B,C)->D

 A => Receiver Object
 B,C=>Args
 D=>Return Type

3.In case of async programming, in order to represent "callbacks/listeners" functions are represented as suspend function.

suspend (A,B)->D
suspend A.(B,C)->D

eg:
  (a:Int,b:Int)->Int

Here no variables are nullable, what if i want nullable representation..

((A,B)->C)?
(A.(B,C)->D)?

Function declaration with variables

action:()->Unit

 action is just variable
 ()->Unit - Function type

Function Literals:
..................
  In functional Programmings "function are values/literals/expressions", can be stored into a variable.
  Since functions are stored into variables, that variables can be used to invoke that function.
 
   var hello: () -> Unit = fun() {
        //function body
        println("Hello function literal")
    }
Here 
=> hello is just variable
=> ()->Unit is Data type , the type of Function
=> fun(){} -It is value

Here you can note down there is no name for function , if function has no name called "Anonyous Functions (functions without name)"

eg:
fun main() {
    var a: Int = 10
    //var is keyword
    //a is variable
    //Int is type
    //10 is literal(value)

    //hello is variable
    //var is keyword
    //()->Unit is type: function type
    //fun(){} - literal/value
    var hello: () -> Unit = fun() {
        //function body
        println("Hello function literal")
    }
    //invoke function :using variable called hello
    hello()
}

Type Inference and Function literals:
.....................................
Type inference is allowed with function types

fun main() {
    //Type Inference with function literals
    var hai = fun() {
        //function body
        println("Hai function literal")
    }
    hai()
}

Function literals with Args and Parameters
.........................................

1.With Explicit Type
fun main() {
    //fun with args and parameters
    var add: (Int, Int) -> Int = fun(a: Int, b: Int):Int {
        return a + b
    }
    println(add(10,10))
}
2.With Type Inference
fun main() {
    var substract = fun(a: Int, b: Int): Int {
        return a - b
    }
    println(substract(10, 8))
}

3.With default Values
fun main() {
    //fun with args and parameters
    var add: (Int, Int) -> Int = fun(a: Int= 0, b: Int = 0): Int {
        return a + b
    }
    println(add(10, 10))
    println(add())

    var substract = fun(a: Int=0, b: Int=0): Int {
        return a - b
    }
    println(substract(10, 8))
}

Note: 
 You will get compile time error.

 "An anonymous function is not allowed to specify default values for its parameters"

Nullable and Anonymous Functions
.................................
fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message ;
    }
    println(accept("Hello"))
    println(accept(null))
}

This code causes compile time error

"Reference has a nullable type '((String) -> String)?', use explicit '?.invoke()' to make a function-like call instead"


if function literal is called with nullable, you cant call directly.

We have patterns to call function literals with Nullable

Pattern 1: "Surround with Null Check"
fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message;
    }
//    println(accept("Hello"))
//    println(accept(null))
    //Pattern 1: "Surround with Null Check"
    if (accept != null) {
        println(accept("Hello"))
    }
}

Pattern 2: There is method called "Invoke",along with "Safe Navigation Operator".

 println(accept.invoke("Hell Invoke"))
Compile Time Error:

Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type ((String) -> String)?

fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message;
    }
    println(accept?.invoke("Hell Invoke"))
}

Nullable For Indiduval Parameters and Returns
.............................................
fun main() {

    var display: (String?) -> String? = fun(message: String?): String? {
        return message ?: "Default"
    }
    println(display?.invoke("Hello"))
    println(display?.invoke(null))

    var showMyName: (String?, String?) -> String? = fun(name: String?, message: String?): String? {
        return "$message $name"
    }
    println(showMyName?.invoke("Subramanian", "Hello"))
    println(showMyName?.invoke(null, null))

}

The Nullable with Receiver Object

(receiverObject.(String?, String?) -> String?)?


Type Inference with Nullable Function type:
..........................................
fun main() {

   //Type inference simplifies the function types
    var show = fun(name: String?, message: String?): String? {
        return "$message $name"
    }
    println(show?.invoke("Subramanian", "Hello"))
    println(show?.invoke(null, null))

}
.....................................................................................
			   Higher order functions
.....................................................................................

=>Function as Parameter to another function
=>Function as return value from another function


Function as Parameter:
......................

fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
  print(add(10,10))
}

Here we can see that function called "add" accepts two numbers

a is variable which type is Int
b is variable which tpe is Int.

Similar to 10 , We consider function as parameter

Basic Higher Order Function
fun add(a: Int, b: Int): Int {
    return a + b
}


//Higher order function:
fun sayGreet(action: () -> Unit) {
    action()
}

fun main() {
    //passing hard coded value
    println(add(10, 10))
    var x = 10
    var y = 20
    //passing variables
    println(add(x, y))

    var greet: () -> Unit = fun() {
        println("Greet")
    }
    sayGreet(greet)
    //passing anonmous function as parameter directly
    sayGreet(fun() {
        println("Greet anonymous")
    })

}







































































































































































