				 Kotlin

Software setup:
1.JDK 17
2.Intellij Idea - community edition.
.....................................................................................

What is Kotlin?
  Kotlin is one of the programming language.
  Kotlin is programming language for "JVM".

What is JVM?
  Java Virtual Machine, which is the process used to run java applications.
  JVM is abstract computer which solves the problem of Platform Independant.

What is Java?
   According to Sun Micro System, Java is  technology.

What is technology?
   Technology means solving the Pratical real time Problems.

Why Java Technology created?
   Since java is technology, it must have created for solving some problems.

Java was created to solve the problem of "Platform Specific Application Development"
in other words, java was created to solve the problem of "Platform Independant".
Before Java apps were used to build using c and c++  programming languages.

Java Technology brought many things.

Java means lot 

1.Java Programming language
2.tools 
    compilers,debuggers,libs,apis
3.Runtime- JRE
4.JDK

What is Java Programming language?
  Java Programming language was created based on "c++,Small Talk,C" like languages.

Java features
1.Java was created based on the style called "Object oriented"
2.Java removed pointers 
3.java added lot of new features automatic memory management
4.Java introduced  Platform independant Threading features
etc....

How java achives the platform independant?
 JVM is abstract machine through which we can achive platform independant features.

After publishing java, Sun Micro systems wanted to improve java technology for that who formed non profitable organziation who standarize the java technology.

JCP - Java Community Processs:
..............................
JCP is organization who standards java technology even today.

After SUN Micro systems, Java technology was acquired by "Oracle".

Classification of Java Technology:
..................................
JCP classifies the Java into three Major Editions

1.JAVA SE - Standard Edition
2.JAVA EE - Enterprise Edition
3.JAVA ME - Micro Edition
.....................................................................................
JCP has published so many specifications.
Java Versions are released by JCP only - java 11, java 12,java 17,java 18,java 20...
.....................................................................................
			JSR 223 :Scripting For the Java Platform
....................................................................................
JSR 223 Spec was released on June-10-2023.

Why this spec?
 Before JSR 223, Only one programming langugage was there for JVM-Java programming language.

This spec aim was to introduce new languages for JVM. - Poly Glot languages for java platform.
.....................................................................................
		  Birth of new Programming languages for JVM
.....................................................................................

Based on this spec , the first language other than java pl was created for JVM - Groovy Programming language.
.....................................................................................

Top JVM languages today
 
1.Java
2.Kotlin
3.Scala
4.Groovy
5.Clojure
6.Fantom
7.Ceylon
8.Jython
9.JRuby
10.Frege
11.Xtend
12.Golo
13.Concurnaas
14.Yeti

	Java PL  Groovy Scala Kotlin Closure Any
       ..........................................
			|
		    Byte Code
			|
		       JVM

All programming langagues compiles their code into byte code which is platform independant code.
.....................................................................................
		 
How the programming languages differs each other?
  
   The every programming languages follows different programming styles.

Programming styles:

There are numerous programming styles are available.

1.Object oriented
2.Functional Programming
3.Procedural Programming
4.Rule Based Programming
etc........

if i want to create new programming language, first i need to select any one of the programming style or can combine many styles.

A language can follow one style or many styles

if a language follows one style, that language is called "single style language"
if a language follows many styles , that language is called "Hyibrid style language".

eg:
 C language follows only one style- Procedural Style, so that we can call c language is procedural language.

 C++ language follows only one style- Object oriented Style, so that we call C++ is object oriented language.

 Java language followed initally when it was created one style - Object oriented Style - Java was Object orinted language.

 Later Java (Java 8) introduced feature called "Functional Programming", after that Java became hybrid language- Java is object oriented,functional style programming language.
.....................................................................................
Groovy:
 Groovy was created functional and object oriented programming languages.
 Groovy is the first functional programming language for JVM.

Scala
  Object oriented and functional style language

Kotlin:
  Kotlin is Object oriented, functional style programming languge
.....................................................................................
		 Kotlin is dervied from "Scala and Groovy"
.....................................................................................
		 Language is classififed based on Data types
....................................................................................

1.Strongly Typed /Static Typed 
   The type of variable is decided during compile
 
int a =10;
a="Hello"


2.Weakly typed or Dynamic typed 
  The type of variable is decided during runtime 
  var a=10;
  a="hello"
The type of a is not verified during compile time.

The java is strongly typed
The javascript is dynamic typed

          "Kotlin is dynamic , strongly Typed language"
....................................................................................
		Language is classififed based on Program style
....................................................................................

Programming language is classified based on two category.

GPL - General Purpose Programming language.
    language is used to build any type of apps using "imperative methodology"

DSL  -Domain Specific language
   Language is used to build specific type of apps using "Declarative methodlogy"

Kotlin is kind of GPL and DSL language using "declarative methodlogy"

DSL Code is more declarative

   move left and move right - DSL code
   find Sqrt of 10 - DSL code
   take 1 pile every day at moring 7 am - DSL Code.

Imperative code/Programming:
...........................
 Any program there is two aspects
   ->Infra structure code
   ->Application logic.
What is it? How is it?

Declarative Programming:
  Focus application logic
  more readable
  less boiler plate
  less code code maintaiance because less code
eg:
  list.sort.filter.map.find.flaten
.....................................................................................
   "Kotlin helps to build more declarative DSL ,functional , Object oriented apps"

Kotlin language is highly multi purpose programming language
 ->To build mobile apps->Multiplatform mobile apps - android and IOS apps
 ->To build server side apps- Microservices, RESTFull apis, Dynamic web apps
 ->To build Platform natives apps like C++.


Learning Path:
..............
1.language fundamentals
2.Object oriented Programming in Kotlin
3.Functional Programming in Kotlin
4.Exception Handling
5.Data Structures in Kotlin
6.Cocurrency - Co-Routines
7.Async programming /Non Blockings
8.How to build DSL
9.How to use In Mobile Development.
...................................................................................
				 Lanaguage fundamentals
....................................................................................
We are going to build console based kotlin apps

Steps to create Kotlin Project.

You can use any build tool to create kotlin Project

Every kotlin programm is saved with "fileName.kt"


Unlike Java programs , Kotlin programs need not be started with classes, you can start with main method(function).

Kotlin Programming style

1.file based or script based
2.class based - oo style

HelloWorld.kt

fun main(){
    println("Hello Kotlin")
}

In Kotlin:

=>fun is used to declare a function
=>The main function is where your program starts from
=>The body of a function is written within curly braces {}
=>println and print functions print the their arguments to standard output.
=>In Koltin ";" is optional.
.....................................................................................
Kotlin Program Structure:

Programs are collection of Instructions.

Instructions = (Information + How the information is stored,processed,retrived)
information is nothing but data.

We need to store data in memory adress, in order to store we need to handle that memory address.

Variables:
 It is handler to store data.

Data 
 -Simple data- atomic data -Primitive data
 eg: 10,char,true or false, decimals 10.45

Any Data can be broken into smaller unit.

Numbers
  1.whole numbers
    - binary,oct,hexa 
  2.Decimal numbers
     -Float,Double

Abstract Data types:
  In the begining of programming only basic types were used by languages like numbers, characters.

How to create our own Data type/Type Custom?
   Custom Types

Struct,Union  - C implementation of Abstract Data types...

Any Abstract/Custom type is built on top of core types.

eg:
  struct Employee = {numbers,characters}
 
Here Employee is Type called custom type/abstract type

After struct and union in c language, new type construct introduced called "class"

 class Employee {
   numbers
   characters
 }

Type -Data Types
 -Primitives
 -Complex/Custom/Reference types


Variables:
  -Holder to hold any type

Literals:
  -values
    ->Primitive Literals
    ->Complex Literals


In Kotlin Types are dervided from java language.

Java Primtives:
1.Numbers
  -byte,short,int,long
  -float,double
2.char
3.boolean

	"In Kotlin we cant use primtive types directly, rather we have to use always
	 Reference/complex types only"


	In Kotlin every thing is object, Every object type is reference Type.
.....................................................................................

Varibles:

  Variables are introduced using two keywords

1.var keyword
2.val keyword

Syntax:
  var | val | withoutAnyKeyword = variableName:Type = literal(value)


fun main() {
    println("Variables and Values")
    //int a=10; java syntax
    var b: Byte = 90 // size is 1 byte
    var s: Short = 100 //size is 2 bytes
    var i: Int = 100 // size is byte 4 bytes
    var lng: Long = 92232323 //size is 8 bytes
    println("Byte "+b)
    println("Short " + s)
    println("Int " + i)
    println("Long " + lng)
    
}

Strings:
fun main() {
    var firtName: String = "Subramanian"
    var lastName: String = "Murugan"
    println("Name " + firtName + lastName)
}

Float and Double:
fun main() {
    var price: Float = 100.9f
    var totalPrice: Double = price * 100.89
    println("Price and Total Price " + price + " ," + totalPrice)
}

Booleans:

fun main(){
    var isEnabled:Boolean = true
    println("IsEnabled " + isEnabled)
}
.....................................................................................
			 Type Inference
.....................................................................................

The type of the variable is "infered" automatically based on the literals.

Explicit type declaration:

var a:Int =10

Type inference Declaration

var a=10

 Here no type is mentioned explicity : type inference.

fun main() {
    var a = 10
    println("A " + a )
    //a="hello" ; it is invalid
    var price =10.4
    println("Price " + price )
    //price =19.4f it is invalid
    var status = true
    println("Status " + status)

}

Kotlin language is "strongly typed/static type language, even though language looks like without type, but type is infered
....................................................................................
				Strings
...................................................................................

String is collection of 16 bit unicode characters
String is object , so that is reference type
Strings are declared using "" or """

Strings are concated with + =>> Traditional style.

Kotlin supports the concept called "String Templates" - String interpolation.

 "$Variable" or "${Variable}

When ever you concat strings use always the above syntax.

fun main() {
    var firstName = "Subramanian"
    var lastName = "Murugan"
    println("Name " + firstName + lastName) //traditional way
    println("Name is $firstName $lastName")
    println("Name is ${firstName} ${lastName}")
}
.....................................................................................
			Mutli Line Strings
.....................................................................................

Java style:

fun main() {
    var doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body> </body></html>"
    print(doc)
}

Kotlin Style:
"""
fun main() {
    var title = "My Page"
    var doc = """
           <html>
            <head>
              <title>${title} </title>
            </head>
            <body>
              <h1>Hello</h1>
            </body>
            </html>
        """
    print(doc)
}
.....................................................................................			    Static Typed language or Dynamic Typed Language



Static Type:
 
int a =10
a=100 // valid
a="hello" // it is invalid: Compile time error


Dynamic Typed:

Javascript :

let a =10; // valid - number
a="Hello" // valid - string
a=true //valid -boolean

In Groovy: 
    Groovy is dynamic Typed language
def  a =10 // valid
a="Hello"  //valid
a =true //valid

Kotlin is Language "Strongly typed or Static Typed" language even though language looks like without type, but the type is infered.

fun main() {
    //def  a =10 :Groovy
    var a = 10 // here type inference is enabled
   // a="Hello" //Kotlin: Type mismatch: inferred type is String but Int was expected
}
....................................................................................
			Basic Operators
.....................................................................................

All Operators supported by Java language Supported by Kotlin as well.

Types of Operators:
......................

1.Arthimetic Operators
2.Conditional Operators
3.Logical Operators

Arthimetic Opertors:
....................
fun main() {
    var a = 10;
    var b = 20
    //add
    var c = a + b
    println("Add Result $c")
    c = a - b
    println("Substract Result $c")
    c = a * b
    println("Multiplication Result $c")
    c = a / b
    println("Division Result $c")
    c = a % b
    println("Mod Result $c")
    //Augmented Operators
    var counter = 1
    counter += 1
    println("Counter $counter")


}

Logical Operators:
fun main() {
    var isValid = true
    var isEnabled = false
    //&&
    var result = isValid && isEnabled
    println("And Operator Result $result")

    result = isValid || isEnabled
    println("And Operator Result $result")
}


Comparsional operators
fun main() {
    var x = 10
    var y = 20
    var isEqual = x == y
    println("Is Equal $isEqual")
    var str = "hello"
    var strCp = str
    var refEqual = str == strCp
    println("Reference Equal $refEqual")

    //Less than and greater than
    var isBig = 100 > 200
    println("IsBig $isBig")
}
.....................................................................................
			Conditional Flow
....................................................................................

Conditions: if

In Kotlin, "if" is an Expression.
It can return a value like functions.
So In Kotlin there is no need for tenary operator :There is no tenary operator 
(Condition ? truthy:fasly) - Similar construct if expression provides
(Condition ? then:else)

IF:
fun main() {
    var a = 100
    var b = 20
    var max = a
    //Traditional way
    if (a < b) {
        max = b
    }
    println("Max $max")
    //Kotlin Expression Style
    if (a < b) max = b // Here we return max variable : looks like function return value
    println("Max $max")

}

IF...ELSE:
.........
fun main() {
    //IF ELSE
    var a = 100
    var b = 10
    var max = a
    //traditional:java style
    if (a > b) {
        max = a
    } else {
        max = b
    }
    println("MAX $max")

    //Kotlin Expression style
    max = if (a > b) a else b
    println("MAX $max")

    var isValid = true

    var status = if (isValid) "Valid" else "Invalid"
    println("Status $status")

}

IF ....ELSE..IF
fun main() {
    var a = 100
    var b = 2
    var maxLimit = 1
    var maxOrLimit = if (maxLimit > a) maxLimit else if (a > b) a else b
    println("maxorMaxLimit is $maxOrLimit")
}

if condition and block of code:
.................................
fun main() {
    var isEnabled = false
    var res = if (isEnabled) "Enabled" else "Disabled"
    println("Result is $res")

    //block of code
    res = if (isEnabled) {
        println("Some code")
        println("some even if more code")
        //must return value
        "Enabled"
    } else {
        println("some else code")
        println("some even extra else code")
        "Disabled"
    }
    println("Result is $res")
}
.....................................................................................
				When Expression
.....................................................................................

When defines a conditional expression with mulitple branches. It is similar to the "switch" statement in c like languages

Syntax:

when(expression) {
   value 1 -> code 
   value 2 -> code 
   value N -> code
   else -> {
      code
   }
}
When "matches" its arguments against all branches sequentially until some branch condition is satisfied.

When can be used either as "expression" or as a "statement".

if it is used as an expression, the value of the first matching branch becomes the value of the overall expression.

if it is used as statement,the values of individual branches are ignored.

Just like with "if", each branch can be a block, and its value is the value of the last expression in the block.

The else branch is evaluated if none of the other branch conditions are satisifed.

if "when" is used as an expression, the else branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions.


Simple When:

Statement Based Syntax:
........................

fun main() {
    var x = 1
    when (x) {
        1 -> println("X is 1")
        2 -> println("X is two")
        10 -> println("X is 10")
        else -> println("No Match Found")
    }
}
....
One block can be used to satisfy multiple expressions.

fun main() {
    var y = 100
    when (y) {
        0, 1, 2, 3, 4, 5, 6, 7 -> println("0 to 7 met")
        8, 9, 10 -> println("8 to 10 met")
        else -> println("No Match Found")
    }
}

I want to write expression to match like

0 to 100
101 to 1000
1001 to 10000

There is an operator called "range" operator 

Range Operator:

1..100 - Numerber Range
a..z - Alphabet Range
A..Z - Alphabet Range

Simple Range: 
fun main() {
    //Type of numbers wouldbe IntRange
    var numbers = 1..10
    for (num in numbers) {
        println("num $num")
    }
    var alphabets = 'a'..'z'
    for (letter in alphabets) {
        println("letter $letter")
    }
}

Note: Advanced Range operations to be discussed later.

fun main() {
    var x = 600
    when (x) {
        in 1..100 -> println("X falls in range of 1 to 100")
        in 101..1000 -> println("X falls in range of 101 to 1000")
        else -> {
            println("X does not fall under the range")
        }
    }
}
.....................................................................................
When is used as "Statement":

  var x = 1
    when (x) {
        1 -> println("X is 1")
        2 -> println("X is two")
        10 -> println("X is 10")
        else -> println("No Match Found")
    }

When is used as "Expression":
............................

var result = when (expression) { 
     value1 -> "Return"
     value2 ->  "Return"
     else -> "Return"
}
fun main() {

    //Expression based
    var isLoggedIn = false
    var status = when (isLoggedIn) {
        true -> "Logged In"
        false -> "Not Logged In"
    }
    println("Status $status")
  
}
.....................................................................................
When with without arg:
.....................
fun main() {
    var num = 3
    var isEvenOrOdd = when {
        num % 2 == 0 -> "Even"
        num % 2 != 0 -> "Odd"
        else -> "No Match Found"
    }
    println("Result is $isEvenOrOdd")
}
....................................................................................
				Loops
...................................................................................

1.for loop
2.range 
3.while
4.do..while

1.For loop:
............

The for loop iterates through anything that provides iterator.
This is eq to C#, or Iterators in java.

Syntax:
 for(item in collection) statement
 
The body of for can be a block also.
  for(item:Type in collection){
    //block
  }
 
eg:

fun main(){
    for(item in 1..100){
        print("${item}, ")
    }
}

Ranges:
fun main() {
    //simple range
    for (i in 1..10) {
        print(i)
    }
    println("\n")
    //Reverse order
    for (j in 10 downTo  1) {
        print(j)
    }
    //increment by 2
    for(counter in 1..100 step 2) println(counter)

    //until
    for(counter in 5 until 10) println(counter)
}

While and do while remain same like c/c++/java 
.....................................................................................	
				Functions
....................................................................................

What is function?
  The term function is derived from the mathmetics.
  The function represents unit of Execution.
  The Function is building block of computer system itself

Types of functions with respect to declaration and execution
1.Passive function
2.Active function

Every Program is running on Runtime which itself is another program.

Every java program is running on JVM Which is another Program.

JVM is written in C language.

According to OS, JVM is just process.

Every Process has three segments(memory Area)

1.Heap
2.Stack
3.Program Data/Method Area

Program data/Method Area:
........................
It is memory segement where all "Passive Instructions" of the Program stored.
All functions are stored/initalized in this area.
All Static variables are initalized inside method area.
All literals(values)  are initalized inside constant pool of method area.

...................................................................................
			 Runtime representation of functions
...................................................................................

In Programs runtime Representation means, which should be accessed by CPU.
If any instructions needs to be accessed by CPU means, it should be available inside Main Memory.

Every function must be allocated on RAM, So that it can be accessed by CPU...

Declaration 
fun main(){ }

Function declaration means which is avilable as part of Method area

Execution: Allocating Memory on RAM
main() --->We have to allocate memory on RAM ----?

When the function is called, that function is pushed into "Stack".

Stack is simple Last In First Out Datastructure.

Once the function gets pushed into Stack,the Runtime allocates memory on RAM.

Stack Framework:
 Stack Framework is nothing but , the runtime representation of every function.
 Stack Framework contains instructions like local variables,Stack Begining  pointer,Return address from where the function gets called.
  
Stack Frames are executed sequentially by default.

hello()--->pushed into stack---creates Frame---running frame----frame returns--frame is removed from main Memory.

.....................................................................................
			Kotlin functions
...................................................................................

Kotlin supports different types of functions

1.normal function
2.infix function
3.local function
4.member function
5.Tail Recursive function
6.inline functions
7.suspend functions
8.operator functions
9.lambda functions

1.Normal Functions
 ->How to declare
 ->How to invoke
 ->Args and Parameters
 ->Return values and types
 ->Types and Parameters

Every kotlin programs begins with main function, which is called by runtime.


Basic Function Declaration:
fun main() {
    println("main function starts")
    hello()
    println("main function ends")
}

//function declaration
fun hello() {
    println("hello")
}

Function with some kind of Logic:
.................................
//function declarations
fun add() {
    var a = 10
    var b = 20
    var c = a + b
    println("C $c")
}

fun multiply() {
    var a = 10
    var b = 20
    var c = a * b
    println("C $c")
}

fun main() {
    add()
    multiply()
}
.....................................................................................
			Functions args and parameters
.....................................................................................

Args are place holders which hold values(literals)
Parameters are values/literals which to be passed to the function.

Simple Args and Parameters:
...........................

//args
//message is argument
fun sayHello(message: String) {
    print(message)
}

fun main() {
    //Hello is parameter
    sayHello("Hello")
}


Function args and params with Logic;
....................................
fun add(a: Int, b: Int) {
    var c = a + b
    println("Add Result is $c")
}

fun multiply(a: Int, b: Int) {
    var c = a * b
    println("Multiply Result $c")
}

fun main() {
    add(10, 10)
    multiply(10, 10)
}

..................................................................................
			Advanced Parameters and Args - Default Args
................................................................................

Use case: passing all Parameters to the function
 Note: by default you cant miss any parameters

fun format(
    str: String,
    normalizeCast: Boolean,
    upperCaseFirstLetter: Boolean,
    wordSeparator: Char
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    format("hello", true, false, ',')
}

Here
 format("hello", true, false, ',') you are passing all parameters

....

Default Args:

//Defalut args
fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    format("hello", true, false, ',')
    format("hai")
    format()
}
.....................................................................................
			 Named Paremeters
..................................................................................

By default , Parameters are passed based on Positions called "Positional Parameters"

fun add(a:Int,b:Int){

}
here you have to pass parameters based on postions like "a" must be passed in first and "b" must be passed second

add(10,20) (a,b)

In Kotlin you can change the positions of parameters called "Named Parameters".

fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

}
Here i want to pass only word separator , the rest of the values should be default one.
//Defalut args
fun format(
    str: String = "Default Str",
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = '.'
) {

    println(
        "str $str normalizeCast $normalizeCast  upperCaseFirstLetter" +
                " $upperCaseFirstLetter wordSeparator $wordSeparator"
    )

}

fun main() {
    //Positional Parameters
    format("hello", true, false, ',')
    format("hai")
    format()

    //Named parameters
    format(wordSeparator = ':')
    format(str = "How are you", upperCaseFirstLetter = true, wordSeparator = ';')
}
....................................................................................
			   How to return values from the function
....................................................................................

In Kotlin function returns Object.
if function does not return any thing, It returns by default One Object called "Unit"
Unit is Type with only one Value -Unit.
Unit value does not have to be returned explicitly.

Unit:

fun doStuff(): Unit {
    println("This function does not return any thing")
}

fun main() {
    var res = doStuff()
    println(res)
}

Other Return Types: Int,String,Boolean,Anything....


fun calculate(a: Int = 0, b: Int = 0): Int {
    return a + b
}

fun sayMyName(name: String = "Default Name"): String {
    return name
}

fun main() {
    var res = calculate(b = 10, a = 30)
    println("Calcualte Result $res")
    var name = sayMyName(name = "Subramanian")
    println("Name $name")
}
....................................................................................
			  Single-Expression Functions
.....................................................................................

When a function returns a single expression, the curly braces can be omitted and the body is specified after = symbol.

Normal Function:
fun sum(a: Int = 0, b: Int = 0): Int {
    return a * b
}

fun main() {
    println(sum(a = 90, b = 89))
}

/**
 * Normal function
fun sum(a: Int = 0, b: Int = 0): Int {
return a * b
}
 **/
//Single Expression Function
//Here we can omit curly braces and return statement.
fun sum(a: Int = 0, b: Int = 0): Int = a * b
fun getStock(value: Double): Double = value

//Here even we can omit return Type: Type Inference is enabled
fun double(x: Int) = x * 2
fun main() {
    println(sum(a = 90, b = 89))
    println(getStock(value = 10.89))
    println(double(x = 10))
}

Note:
Explicit Return types

1.Functions with block body must always specify return types explicitly,unless it's intended for them to return "Unit", in which case specificing the return type is Optional.

2.Kotlin does not infer return types for functions with block bodies because such functions may have complex control flow in the body, and the return type will be non obvious to the reader.
....................................................................................
				Null
....................................................................................
What is null?
  Null itself is value, Its type is Object.
  Null itslef is object.

History Of Null:
  In computing, a null pointer or null reference is a value saved for indicating that the pointer or reference does not refer to a valid object(value).

In 2009, Tony Hoare stated[15] that he invented the null reference in 1965 as part of the ALGOL W language. In that 2009 reference Hoare describes his invention as a "billion-dollar mistake":

reference: https://en.wikipedia.org/wiki/Null_pointer
.....................................................................................
			How to handle Null?

"Null" Reference is unavoidable in any Object Oriented Systems like c++,java,C#,Kotlin etc...

Handling null is more challange

How to handle null very safely?

Kotlin like languages handles null very effieciently without crashing the system with minimual , declarative code.

Kotlin handles null positively, if there is null, we can give alernate values.

How null is handled in java?
 In java, the methods,properties  access are verified during compile time.
 Invocations are verified during runtime only.
 if there is any null reference, jvm throws error during runtime.
 null cant be verified during compile time.


public class NullDemo {
    public static void main(String[] args) {
        String str = null;
        System.out.println(str.length());
    }
}
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "str" is null
	at NullDemo.main(NullDemo.java:5)

In Kotlin "null" is verified during "Compile" time,So that Your code will be more safer during Development.
Most of the null reference bugs can be identified
.....................................................................................

In java null is handled

A a =null

if(a!=null){ 
   do
}else{ 
  dont do
}

public class NullDemo {
    public static void main(String[] args) {
        String str = null;
        if (str != null) {
            System.out.println(str.length());
        } else {
            System.out.println("There is no object");
        }
    }
}

Kotlin and Null:
..................

1.Kotlin variables never allows null by default.

fun main(){
    var message:String =null
}
This code cause compile time error
 "Null can not be a value of a non-null type String"

fun main(){
    var message:String=""
    message = null 
}
This code also causes error.

Sometimes we cant avoid having null values.
How does we declare "null" in Kotlin?

You can declare variable "nullable" - variable can have null.

Synatax:
  var variableName:Type? = null

Eg:
fun main() {
    //var message:String=""
    // message = null
    var message: String? = null
    println(message)
}
.....................................................................................
		 What if I access any property on null Reference
....................................................................................

fun main() {
    var message: String? = null
    println(message.length)
}
You will compile time error if you access any property on "null" object.

"Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?"

Ways to Handle null Reference
..............................

1.Java Style : using if and notNull 
fun main() {
    var message: String? = null
    //println(message.length)
    //message="hello"
    //way 1: java style
    if (message != null) {
        println("Message Size is ${message.length}")
    } else {
        println("Message Size is having null value")
    }
}

2.Kotlin Style: Using there is operator "Safe Navigation Operator"
?. - SafeNavigation Operator.

var message:String? = null
println("Message Size Using Safe Navigation Opertor ${message?.length}")

if the variable is having null reference, The output would be "null"  
if the variable is having value, The output would be "value"

fun main() {
    var message: String? = null
    //println(message.length)
    //message="hello"
    //way 1: java style
    if (message != null) {
        println("Message Size is ${message.length}")
    } else {
        println("Message Size is having null value")
    }
    //Way 2: Kotlin Sytle : Using SafeNavgiation Operator
    println("Message Size Using Safe Navigation Opertor ${message?.length}")

}
output:
Message Size is having null value
Message Size Using Safe Navigation Opertor null

3.Kotlin Sytle:Using Elvis Operator
  If there is null in output, it would be replaced with some default value, that means some meaningfull default values

var result = variableName?.property ?:defaultValue

fun main() {
    var message: String? = null
    //Way 3:Kotlin Style: Using Elvis Operator
    var length = message?.length ?: 0
    println("Message Size Using Elvis Operator ${length}")

}
output:
Message Size Using Elvis Operator 0

4.Kotlin Style: Producing RuntimeException using NotNull Assertion Operator(!!)

  For Some Reasons, if you want "RuntimeException" to be thrown by the code
  How to throw RuntimeException.
  
Syntax:
 Variable!!.Property

fun main() {
    var message: String? = null
    //Way 4: Kotlin Style:Using Not Null Assertion Operator(!!)
    println("Message Size using Not Null Assertion Operator ${message!!.length}")

}
output:
Exception in thread "main" java.lang.NullPointerException
	at KotlinNullAccessKt.main(KotlinNullAccess.kt:19)
	at KotlinNullAccessKt.main(KotlinNullAccess.kt)


Safe Cast and Collections and Null : To be discussed later.
.................................................................................
				Functions,Null and Nullable
...................................................................................

Parameters and Null:


fun save(name: String? = "", city: String? = "", age: Int? = 1) {
    println("${name?.uppercase() ?: "Name".uppercase()} ${city?.uppercase() ?: "City".uppercase()} ${age ?: 1}")
}

fun main() {
    save(name = "Subramanian", city = "Coimbatore", age = 43)
    save(name = null, city = null, age = null)
}

Return Type and Null:
fun find(): String? {
    //return "find";
    return null
}


fun main() {
    println(find() ?: "empty")
}
.....................................................................................
				Functional Programming
.....................................................................................

What is Functional Programming?
  Functional Programming is one of the programming style for building apps.

History of Functional Programming:
..................................

Functional Programming principles and patterns implemented from the "Mathmetics" called "Lambda Calculs".

Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution.

It is a universal model of computation that can be used to simulate any Turing machine.

It was introduced by the mathematician Alonozo Church in the 1930s as part of his research into the foundations of Mathmetics.

"Turning Machine"  is abstract computer which talks about how to "mutate state" / "Manipulate state".

What is meaning of Function according to "Lambda Calculs"?

  Function means "Unit of Computation" - Having expressions and variables and its values

f = {
  c = a + b
}

Functional Programming is the implementation of "Lambda Calculs" theorems...

The languages which implements "lambda Calculs" We call "functional programming language".

The first functional Programming language introduced in 1950's 
=>Lisp - First Appeared in 1960.

Based on Lisp language many languages were created

Most popular languages today
1.java script
2.Kotlin,scala,java 8
etc...

Principles of Functional Programming(Lambda Calculs):
.....................................................

1.Pure functions
  1.1.Side Effects,Immutability
2.Functions are first Class citizens 
  2.1.Higher order functions
3.Referential Transparency
4.Recursive functions rather than loops

All priniciples may not be used in all languages.

if a language implements all principles "The language is called "pure functional" Programming language

if a language does not implement all principles The language is called "functional style" Programming language


		"Kotlin is functional style language"


Kotlin functional programming implementations:

1.Function is first class citizens:
....................................

 Firt class means "special"

 -> Functions are passed around (in,out)
  
 This means the language supports passing function as arguments to other functions 
   -In
 Returning functions from other functions as "values"
  -Out

 Assigning functions into variables or stroing them inside data structures.
 
var a:Int =100
 
 a- is variable
 Int is data type
 100 is literal

Similar to 100 we can assign or treat functions..

According to functional Programming "function is literal /value" like int,double,string.

var variableName = fun myFun(){}

 "Kotlin functions are first class citizens, which means that they can be stored into variables, passed inside ds, as parameter, return them from other functions".

Higher Order Functions:
.......................
	First class functions are necessity for the functional programming style,in which the use of higher order functions is a standard practice.

In Mathmetics and Computer Science, a higher order function is a function that does the following things

1.takes one or more functions as arg
2.returns a function as its result.

Can i say this function is higher order fun?

fun map(){

}
 No, Because  it does not follow the thumb rule of higher order functions.
.....................................................................................
			Kotlin and functional programming implementations
.....................................................................................

Since Kotlin Static typed language, We need to tell the "Type of Itself"

fun map(FunctionType){

}

In kotlin , every thing is Object, FunctionType itself is Object behind the Scene
...................................................................................
			 Kotlin Functions types
...................................................................................

1.(T)->T
 eg:
  (Int)->Int
  (Int)->String
2.(T1,T2)->T3
  (Int,Int)->Int
  (Int,Int)->String
3.(T)->Unit
  (T)->Unit
  ()->Unt

fun map((T)->T) {

}
fun map((T1,T2)->T3) {

}
fun map((T)->Unit) {

}
Rules:
1.All Function types have a parenthesized type list and return type.
  (A,B)->c

2.Function type can Optionally have an additional "Receiver" Type,
  Which is represented a dot in the notation.
 
   "ReceiverObject".(B,C)->D
eg
    A.(B,C)->D

 A => Receiver Object
 B,C=>Args
 D=>Return Type

3.In case of async programming, in order to represent "callbacks/listeners" functions are represented as suspend function.

suspend (A,B)->D
suspend A.(B,C)->D

eg:
  (a:Int,b:Int)->Int

Here no variables are nullable, what if i want nullable representation..

((A,B)->C)?
(A.(B,C)->D)?

Function declaration with variables

action:()->Unit

 action is just variable
 ()->Unit - Function type

Function Literals:
..................
  In functional Programmings "function are values/literals/expressions", can be stored into a variable.
  Since functions are stored into variables, that variables can be used to invoke that function.
 
   var hello: () -> Unit = fun() {
        //function body
        println("Hello function literal")
    }
Here 
=> hello is just variable
=> ()->Unit is Data type , the type of Function
=> fun(){} -It is value

Here you can note down there is no name for function , if function has no name called "Anonyous Functions (functions without name)"

eg:
fun main() {
    var a: Int = 10
    //var is keyword
    //a is variable
    //Int is type
    //10 is literal(value)

    //hello is variable
    //var is keyword
    //()->Unit is type: function type
    //fun(){} - literal/value
    var hello: () -> Unit = fun() {
        //function body
        println("Hello function literal")
    }
    //invoke function :using variable called hello
    hello()
}

Type Inference and Function literals:
.....................................
Type inference is allowed with function types

fun main() {
    //Type Inference with function literals
    var hai = fun() {
        //function body
        println("Hai function literal")
    }
    hai()
}

Function literals with Args and Parameters
.........................................

1.With Explicit Type
fun main() {
    //fun with args and parameters
    var add: (Int, Int) -> Int = fun(a: Int, b: Int):Int {
        return a + b
    }
    println(add(10,10))
}
2.With Type Inference
fun main() {
    var substract = fun(a: Int, b: Int): Int {
        return a - b
    }
    println(substract(10, 8))
}

3.With default Values
fun main() {
    //fun with args and parameters
    var add: (Int, Int) -> Int = fun(a: Int= 0, b: Int = 0): Int {
        return a + b
    }
    println(add(10, 10))
    println(add())

    var substract = fun(a: Int=0, b: Int=0): Int {
        return a - b
    }
    println(substract(10, 8))
}

Note: 
 You will get compile time error.

 "An anonymous function is not allowed to specify default values for its parameters"

Nullable and Anonymous Functions
.................................
fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message ;
    }
    println(accept("Hello"))
    println(accept(null))
}

This code causes compile time error

"Reference has a nullable type '((String) -> String)?', use explicit '?.invoke()' to make a function-like call instead"


if function literal is called with nullable, you cant call directly.

We have patterns to call function literals with Nullable

Pattern 1: "Surround with Null Check"
fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message;
    }
//    println(accept("Hello"))
//    println(accept(null))
    //Pattern 1: "Surround with Null Check"
    if (accept != null) {
        println(accept("Hello"))
    }
}

Pattern 2: There is method called "Invoke",along with "Safe Navigation Operator".

 println(accept.invoke("Hell Invoke"))
Compile Time Error:

Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type ((String) -> String)?

fun main() {
    //What if the paremeter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return message;
    }
    println(accept?.invoke("Hell Invoke"))
}

Nullable For Indiduval Parameters and Returns
.............................................
fun main() {

    var display: (String?) -> String? = fun(message: String?): String? {
        return message ?: "Default"
    }
    println(display?.invoke("Hello"))
    println(display?.invoke(null))

    var showMyName: (String?, String?) -> String? = fun(name: String?, message: String?): String? {
        return "$message $name"
    }
    println(showMyName?.invoke("Subramanian", "Hello"))
    println(showMyName?.invoke(null, null))

}

The Nullable with Receiver Object

(receiverObject.(String?, String?) -> String?)?


Type Inference with Nullable Function type:
..........................................
fun main() {

   //Type inference simplifies the function types
    var show = fun(name: String?, message: String?): String? {
        return "$message $name"
    }
    println(show?.invoke("Subramanian", "Hello"))
    println(show?.invoke(null, null))

}
.....................................................................................
			   Higher order functions
.....................................................................................

=>Function as Parameter to another function
=>Function as return value from another function


Function as Parameter:
......................

fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
  print(add(10,10))
}

Here we can see that function called "add" accepts two numbers

a is variable which type is Int
b is variable which tpe is Int.

Similar to 10 , We consider function as parameter

Basic Higher Order Function
fun add(a: Int, b: Int): Int {
    return a + b
}


//Higher order function:
fun sayGreet(action: () -> Unit) {
    action()
}

fun main() {
    //passing hard coded value
    println(add(10, 10))
    var x = 10
    var y = 20
    //passing variables
    println(add(x, y))

    var greet: () -> Unit = fun() {
        println("Greet")
    }
    sayGreet(greet)
    //passing anonmous function as parameter directly
    sayGreet(fun() {
        println("Greet anonymous")
    })

}
............................................

Function as Parameter with Args and Parameters:
...............................................
fun adder(action: (Int, Int) -> Unit) {
    action(10, 10)

}

fun main() {
    adder(fun(a: Int, b: Int) {
        var result = a + b
        println("The Result is ${result}")
    })
}
...

Function as Parameter with Args and Parameters with Nullable:

Note: 
 When you do numerical compuation against nullable values, you can use still safe Navigation Operator or elvis operator, for this eg i am going to use "java style" null check, that concept we will see later.

fun adder(action: (Int?, Int?) -> Unit) {
    action(10, 10)
    action(null, null)

}

fun main() {
    adder(fun(a: Int?, b: Int?) {
        if (a != null && b !== null) {
            println(a + b)
        } else {
            println("Values are null ")
        }

    })
}

OUtput:
20
Values are null

...
Default Values : 

The below code cause compile time error, because anonymous functions cant have default value

fun adder(action: (Int?, Int?) -> Unit) {
    action(10, 10)
    action(null, null)
    //action()

}

fun main() {
    adder(fun(a: Int?=0, b: Int?0) {
        if (a != null && b !== null) {
            println(a + b)
        } else {
            println("Values are null ")
        }

    })
}
........................................

How to pass more functions as parameter?

->Nullable
->Default values including default functions

fun login(
    userName: String? = "admin",
    password: String? = "admin",
    resolve: ((String?) -> Unit?)? = fun(status) {
        println(status)
    },
    reject: ((String?) -> Unit?)? = fun(err) {
        println(err)
    }
) {

    if (userName === "admin" && password == "admin")
        if (resolve != null) {
            resolve("Login Success")
        }
    else
        if (reject != null) {
            reject("Login Failed")
        }

}

fun main() {
    login(
        userName = "admin",
        password = "admin",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        }
    )

    login(
        userName = "foo",
        password = "bar",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        }
    )
    login()
    login(null,null,null,null)
}
.....................................................................................

Can Parameter function return any value to caller?

Yes
fun connect(action: (status: Boolean) -> String) {
    var result = action(true)
    println(result)
}

fun main() {
    connect(fun(status: Boolean): String {
        println(status)
        return "Connected";
    })
}
.....................................................................................
			Higher order functions and "Lambdas"
.....................................................................................

What is Lambda?
  Lambda terminalogy is derived from "Lambda calculs"

"Lambdas are function literals only, can be assigned to a variable, passed around(in and out)

In order to implement functional programming, we can use lambdas which simplifies the coding even better way.

How to declare lambda expressions?

var | val variableName:FunctionType = { arg ->functionBody }

Rules:

1.A lambda expression is always surrounded by Curly braces
2.Parameter declarations in the full synatactic form go inside curly braces and have optional type annotations.
3.The body of the function will after -> (arrow) notation only

4.The infered return tpe is not "Unit" by default, The last line (possible)   expression inside lambda is treated as the return value.

5.Lambads can be passed as parameter to another function or another Lambda 

Different way of writing functions

1.normal function
2.function expression: if function has only one line of returned code
3.function as literal
4.function as lambda


//normal function
fun myadd(a: Int = 1, b: Int = 1): Int {
    return a + b
}

//single function expression
fun addExpression(a: Int = 1, b: Int = 1) = a + b

//function literal
var addFun = fun(a: Int, b: Int): Int {
    return a + b
}
var addLambda = { a: Int, b: Int ->
    //return
    a + b
}

fun main() {
    println(myadd(10, 10))
    println(addExpression())
    println(addFun(1, 3))
    println(addLambda(10,10))
}
.....................................................................................

Lambda With biz logic:
var loginLambda = { userName: String, password: String ->
    if (userName == "admin" && password == "admin") "Login Success" else "Login failed"
}

fun main() {
    println(loginLambda("admin", "admin"))
}
.......

How to pass lambda as parameter to function or lambda?

//function that accepts lambda as parameter
//no args and no return
fun greeter(action: () -> Unit) {
    action()
}

fun hello(action: (String) -> Unit) {
    action("Hello!!!")
}

fun hai(action: (String) -> String) {
    var res = action("Hai, How are you?")
    println(res)
}

fun main() {
    greeter({ println("hello") })
    greeter({
        println("hello")
        println("hello")
        println("hello")
        println("hello")
        println("hello")
        println("hello")
    })
    //lambda tha takes args
    hello({ message: String ->
        println(message)
    })
    hai({ message ->
        message
    })
}

...

Lambda Accepts another lambda as parameter:
...........................................
fun main() {
    //Lambda accepts another lamabda as parameter
    var greet = { action: () -> Unit ->
        action()
    }
    greet({
        println("Lambda")
    })
    //Lambda accepts another lamabd as parameter which pass some value to the caller lambda
    var add = { action: (Int, Int) -> Int ->
        println(action(10, 10))
    }
    add({ a: Int, b: Int ->
        a + b
    })
}
.............................
Code Refactoring:
   Lambda argument should be moved out of parentheses:

With paraentheses:
 add({ a: Int, b: Int ->
        a + b
    })

Without paraentheses:
 add { a: Int, b: Int ->
        a + b
    }

fun main() {
    //Lambda accepts another lamabda as parameter
    var greet = { action: () -> Unit ->
        action()
    }
    greet {
        println("Lambda")
    }
    //Lambda accepts another lamabd as parameter which pass some value to the caller lambda
    var add = { action: (Int, Int) -> Int ->
        println(action(10, 10))
    }
    add { a: Int, b: Int -> a + b }
}
.......................
Passing more lambda parameters:
...............................
fun main() {
    var login = { userName: String,
                  password: String,
                  resolve: (String) -> String,
                  reject: (String) -> String ->
        if (userName === "admin" && password === "admin")
            resolve("Login success")
        else
            reject("login failed")
    }
    //invoke lambda
    login(userName = "admin",
        password = "admin",
        { status -> println(status) },
        { err -> println(err) }
    )
}
....................................................................................
			it - Variable
...................................................................................
"it" is implicit variable can be used in "lambda"  to replace single explcit arg functions
fun main() {
    //If lambda has single arg and parameter
    var sayMyName = { name: String ->
        name.uppercase()
    }
    println(sayMyName("subramanian"))

    //without variable name
    var sayYourName: (String) -> String = {
        it.uppercase()
    }


}
.....................................................................................
				DSL - Domain Specific language
...................................................................................

What is DSL?
  More Readable code english like statement.
  Kotlin suports building DSL syntax.

1.When we pass lambda as parameter to  the function, we can ommit ()

  //Lambd skips ()

   delay {
	println ("DSL Task")
   }
...................................................................................
			 DSL and Higher order function

if functions/lambda takes args like String/Int,FunctionType
import kotlin.concurrent.thread

fun main() {
    println("dsl code")
    var mytask = { action: () -> Unit ->
        action()
    }
    mytask { println("DSL TASK") }

    var compute = { no: Int, action: () -> Unit ->
        println("$no")
        action()
    }

    fun filterBy(order: String = "asc", name: String = "name", no: Int = 0, action: () -> Unit) {
        println("Order ${order} name ${name} no ${no}")
        action()
    }

    //normal syntax
    compute(10, { println("hello") })
    //when pass lambda as second parameter or last last parameter, the first parameters can be
    //enclosed with in () and second parameter(lambda) can be passed directly
    compute(10) { println("computed") }

    //explicit values
    filterBy(order = "desc", name = "Subramanian", no = 100) { println("Hello") }
    //with default value
    filterBy { println("How are you") }
    //even though function is last you can pass even first parameter
    filterBy(action = { println("Hello") }, order = "desc", name = "Subramanian", no = 100)

    //SOme built in Kotlin functions are higher order functions with lambda
    thread(name = "My thread", start = true) {
        println("Current Thread ${Thread.currentThread().name}")
    }
    thread {
        println("Current Thread ${Thread.currentThread().name}")
    }
}
.....................................................................................
		   Best Practices Designing with Lambda
.....................................................................................

we can use lambda at places of function calls any where, but it does not give DSL Syntax.

if you want DSL coding, pass lambda always last parameter
....................................................................................
			Can we skip lambda args
...................................................................................

Yes we can skip lambda args using "_" notation instead of name.

fun doCompute(a: Int = 10, b: Int = 10, action: (Int, Int) -> Unit) {
    action(a, b)
}

fun main() {
    doCompute { _, b -> println("$b") }
    doCompute(b = 90) { _, b -> println("$b") }
}
....................................................................................
	   Object oriented Programming and Implementations
...................................................................................
What is Object orientation?

  The Object orientation is way or style of building applications.

if you look at any programming language, there are two things

1.data
2.How that data can be operated upon

Program= {Data + actions/operations}

Before OO
  data and operations are completly isloated -Procedural programmings

if many operations operate on data, which lead inconsistency,data corrpution,data duplication

1970's White paper was published regarding this, How to organize the data based on problem domain - real world.

We need to map the data according to realworld problems what we solve using programs and machines.

Birth of Abstract data type:
............................
Create new Type based on core types

core types
 numbers,characters
 numbers - very very core

Language types
  int ,short,byte,long,float,double -primitive types

NewType = {int ,float,char,double}
 |
Abstract Data Type 

Implementation of Abstract data type theory:
............................................

In c language, abstract data type theory were implemented via notations.

1.struct
2.union
 These notations group data and its operations into a logic unit.

class
  The word class is dervied from "Clause" - Grouping of things(data + operations)

Based on this notation, c language introduced a concept called "C with Classes"
the later it led a new Programming language style and implementation
 - object oriented programming.

OO talks about hwo to organize data and its operations togther.

Object | class = { data + operations}

Object is runtime represenation where as class is compile time representation.

Based on classes and Object, principles were published

Object oriented Concepts:

1.Abstraction
2.Encapsulation
3.Typing
4.Hierachy
5.Modularity
...................
6.Concurency
7.Persistency

Abstraction:
   It talks about how to collect data from the real world problem domain "Object"

Abstraction says how to extract "Necessary data" from the object on Given context.

eg:
  if you take Mr x
He goes to bank, What type of information banker needs?
Mr X as Customer
  -name
  -address
  -phone no
  -pan no
  -adhar no
  -email 
  -type of account
  -deposit amount
etc...

Abstraction collects data and organize under single unit called "class"
..................................................................................
			 Classes in kotlin
..................................................................................

How to declare class and properties(variables)

class Customer {
    //data and operations
    var id:Int 
}

fun main() {

}
This code causes compile time error
"Property must be initialized or be abstract"
Note:
 In java if any instance variables(property), not initalized,would be null by default
You know very well, kotlin never allow null by default.

What if i want null?
class Customer {
    //data and operations
    //var id: Int = 0
    //null if want
    var id: Int? = null
    var name:String? = null 
    var city:String? = null
}

fun main() {

}
.........
Memory Allocation:
..................
  In object orientation , memory allocation for a class called "Object creation/instance creation"

var variable:Type = ConstructorCall()

var customer:Customer = Customer()

Note: in Java we use "new" keyword to allocate memory.
 In Kotlin no new Keyword.

class Customer {
    //data and operations
    //var id: Int = 0
    //null if want
    var id: Int? = null
    var name: String? = null
    var city: String? = null
}

fun main() {
    //Expclit type
    var customer: Customer = Customer()
    //Type inference
    var customerOne = Customer()

    //How to access properties
    println("id ${customer.name} Name ${customer.name} ${customer.city}")
}
.....................................................................................
				variables declarations
.....................................................................................

1.using var keyword - can be reinitalized
2.using val keyword - cant be reinitalized - Immutable variables
   "The Original memory address can't be overriden.
fun main() {
    var a = 10
    //reintialization of a
    println(a)
    a = 19
    println(a)
    val b =10
    println(b)
    //b=90
}
.....................................................................................
			State(data properties) initalization
.....................................................................................

1.inside class
2.Outside class after object creation via reference variable
3.During Object creation - Constructors

Inside class:
class Employee {
    //Property intialization inside class directly
    val employeeId: Int? = 0
}

fun main() {
    //var is keyword
    //employee is variable
    //Employee() is constructor call
    var employee = Employee();
}

init block:
 init is special block used to initalize the variables and any code.
A Single class can have multiple init blocks but recommended having only one init block.
init blocks are getting executed the order in which they are declared.

class Employee {
    //Property intialization inside class directly
    //val employeeId: Int? = 0
    var employeeId: Int?

    //init block
    init {
        println("Block 1")
        employeeId = 0
    }

    init {
        println("Block 2")
    }

    init {
        println("Block 3")
    }
}

fun main() {
    //var is keyword
    //employee is variable
    //Employee() is constructor call
    var employee = Employee();
    println("Id ${employee.employeeId}")
}
.....................................................................................
Out side class:
..............
fun main() {
    //var is keyword
    //employee is variable
    //Employee() is constructor call
    var employee = Employee();
    println("Id ${employee.employeeId}")

    //outside class 
    employee.employeeId = 10
    println("Id ${employee.employeeId}")

}

In java , all instance variables either initalized via constructors or setters
It is not recommended using reference variables directly.

Setters :Mutators:
.................
1.It is special method, used to initalize the properties.
2.It is part of java Bean specifications

Kotlin and Setters:
...................

1.Kotlin does not recommend to have setters by default.
2.Kotlin uses implicit setters by default.
  employee.employeedId=10  ===> employee.setEmployeeId(10)


Getters:Accessors:
..................
1.It is special method used to read the properties
2.It is part of java bean specification.


Kotlin and Getters:
1.Kotlin does not recommend to have getters by default.
2.Kotlin uses implicit getters by default.
  println(employee.employeedId) ===> employee.getEmployeeId().

Can we have explicit getters and setters?
  
Yes!

Syntax:
 var <PropertyName>:[PropertyType] =[Property_initalizer]
 [getter]
 [setter]

What is use case of explicit setters and getters?
   if you want to have some extra code or formating coding.
class User {
    var name: String? = null
        //setter
        set(value) {
            //backing field
            field = "Mr / Mrs $value"
        }
        //getter
        get() {
            return field?.uppercase()
        }
}


fun main() {
    var user = User();
    user.name = "subramanian"
    println(user.name)

}
...............................................................................

Computed Properties:
  Coimbing more variables and producing an expression.

class GuestUser {
    var firstName: String? = null
    var lastName: String? = null
    var fullName: String? = null
        //computed property
        get() {
            return "${this.firstName} ${this.lastName}"
        }
}

fun main() {
    var user = GuestUser()
    user.firstName = "Subramanian"
    user.lastName = "Murugan"
    println(user.fullName)
}
..................................................................................
			Getters are Function Expression syntax
..................................................................................
class MyUser {
    var name: String? = null
        set(value) {
            field = "Mr/Mrs $value"
        }
        //normal method syntax
//       get() {
//           return field?.uppercase();
//       }
        get() = field?.uppercase()
}

fun main() {
    val user = MyUser()
    user.name = "Subramanian"
    println("Name ${user.name}")
}
.....................................................................................
How to intialize the object properties during object creation?
Constructors

What is Constructors?

 Constructors are special methods , are used to initalize the object properites during object creation.

Properties Declarations:
........................

Properties are declared in Kotlin in two ways.

1.Inside class
class User { 
  var id:Int?=null
}
2.As part of the Constructor

Types of constructors:

1.Primary Constructor
2.Secondary Constructor

Primary constructors are default Constructors...
Secondary constructors are additional constructors for overloading.

Primary Constructors:
.....................
 Primary Constructors are added as part of class header.

syntax:

class ClassName constructor(){}

Note:
 If the primary constructor does not have any annotations or visibility modifiers, the constructor keyword can be ommited

class ClassName (){}

class ClassName [private | @Something] (){}

"Primary constructors does not contain any code, if want special initalization, should be given inside "init" block.


Note:
 In java you must give multiple constructors for each data pair initalization
like
default constructor and two arg, three arg,n-arg constructors.

How many ways if you want to initalize the object, you have to have those many constructors, in kotlin you dont need those many constructors, because of default values , constructors are dynamically populated.

class Person constructor(
    var firstName: String? = "",
    var lastName: String? = "",
    var age: Int? = 1
) {

}

fun main() {
    //pass constructor parameters
    //default constructor
    var person = Person();
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //all arg constructor
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //two arg
    person = Person(firstName = "Subramanian", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //single arg
    person = Person(age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
}
....................................................................................
			  Without Constructor Keyword


class Person(
    var firstName: String? = "",
    var lastName: String? = "",
    var age: Int? = 1
) {

}

fun main() {
    //pass constructor parameters
    //default constructor
    var person = Person();
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //all arg constructor
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //two arg
    person = Person(firstName = "Subramanian", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //single arg
    person = Person(age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
}
....................................................................................
			Constructors and Init Block
...................................................................................
 //constructors with init block
class Person(
    var firstName: String? = "",
    var lastName: String? = "",
    var age: Int? =0
) {
    init {
        age = 18
    }
}

fun main() {
    //pass constructor parameters
    //default constructor
    var person = Person();
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //all arg constructor
    person = Person(firstName = "Subramanian", lastName = "Murugan", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //two arg
    person = Person(firstName = "Subramanian", age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
    //single arg
    person = Person(age = 43)
    println("firstName ${person.firstName} lastName ${person.lastName} ${person.age}")
}

Output:
firstName  lastName  18
firstName Subramanian lastName Murugan 18
firstName Subramanian lastName  18
firstName  lastName  18

here 18 is final output, because init block is called after constructor call, what ever parameters if you are passing via constructors can be overriden by init block.

Note: if you want new value/updated value, you have to initalize after object creation using "reference variable"
 person.age = 43
.....................................................................................
			Secondary Constructors
...................................................................................

A class can have more constructors expliciltly apart from the primary constructors, Genarlly to mimic the overloading feature.

A secondary constructors are introduced inside class using "Constructor keyword".


class MyClass constructor(){
    //Secondary constructors
    constructor(a:String) {
        println("Constructor with String arg ${a}")
    }
}


fun main(){
    
}

This code throws compile error "Primary constructor call expected".

Note:
  Each Secondary Constructor needs to delegate to the primary constructors either directly or indirectly through anthoer secondary constructors.
Delegation to another constructor for same class is done using "this" keyword.



class MyClass constructor() {
    //Secondary constructors
    constructor(a: String) : this() {
        println("Constructor with String arg ${a}")
    }

    constructor(b: Int) : this() {
        println("Constructor with Int arg ${b}")
    }

    constructor(c: Boolean) : this() {
        println("Constructor with String arg ${c}")
    }
}


fun main() {
    var myclass = MyClass("subramanian")
    myclass = MyClass(100)
    myclass = MyClass(true)
}

output:
Constructor with String arg subramanian
Constructor with Int arg 100
Constructor with Boolean arg true


without constructor keyword
class MyClass() {
    //Secondary constructors
    constructor(a: String) : this() {
        println("Constructor with String arg ${a}")
    }

    constructor(b: Int) : this() {
        println("Constructor with Int arg ${b}")
    }

    constructor(c: Boolean) : this() {
        println("Constructor with Boolean arg ${c}")
    }
}
......................
Without Primary constructors and can we have only secondary constructors?

Yes!.

class MyClass {
    //Secondary constructors
    constructor(a: String) {
        println("Constructor with String arg ${a}")
    }

    constructor(b: Int) {
        println("Constructor with Int arg ${b}")
    }

    constructor(c: Boolean) {
        println("Constructor with Boolean arg ${c}")
    }
}

fun main() {
    var myclass = MyClass("subramanian")
    myclass = MyClass(100)
    myclass = MyClass(true)
}
.....................................................................................	
			  class Memembers
.....................................................................................

A class can have many things.

1.constructors and initalizer blocks
2.properties
3.functions
4.Nested and inner classes
5.Object declarations

Functions and class Declarations:
.................................
class CustomerService {

    //functions / methods
    fun findAll(): String {
        return "findAll"
    }

    fun save(employee: String?): String? {
        return "saved"
    }

    //single function expression
    fun remove(id: Int?) = "$id Removed"
}

fun main() {
    var customerService = CustomerService()
    println(customerService.findAll())
    println(customerService.save("employee"))
    println(customerService.remove(1))
}
.....................................................................................
			Classes - functions higher order, lambda
.....................................................................................
class Util {
    //normal function
    fun sayHai(): Unit {
        println("Hai")
    }

    //literal declaration
    var sayHello: () -> Unit = fun() {
        println("Hello")
    }

    //lambda version
    var add = { a: Int, b: Int ->
        a + b
    }

    //higher order function
    fun login(userName: String = "", password: String = "", resolve: (String) -> Unit, reject: (String) -> Unit) {
        if (userName == "admin" && password == "admin") {
            resolve("login success")
        } else {
            reject("login failed")
        }
    }

    //higher order lambda
    fun delay(action: () -> Unit) {
        action()
    }

    var async = { action: (String) -> Unit ->
        action("async function")
    }
}


fun main() {
    var util = Util()
    util.sayHello()
    util.sayHai()
    println(util.add(10, 10))
    util.login(userName = "admin",
        password = "admin",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        }
    )
    util.delay { println("delay") }
    util.async { println(it) }
}
.....................................................................................
			Nested and inner classes
.....................................................................................
Classes can have other classes called "Nested Class or Inner class".

Inner and outer class declartions
//class outer 
class Outer {
    constructor() {
        println("Outter class constructor")
    }

    class Inner {
        constructor() {
            println("Inner class constructor")
        }
    }
}


fun main() {

}
.....

How to create instance/object for inner classes?

There are are many ways

1.Using outer class function
//class outer
class Outer {
    constructor() {
        println("Outter class constructor")
    }

    class Inner {
        constructor() {
            println("Inner class constructor")
        }
    }

    fun createInner() {
        var inner = Inner()
    }
}


fun main() {
    var outter = Outer()
    outter.createInner()
}

After creating object? How to access inner class properties and methods?

//class outer
class Outer {
    constructor() {
        println("Outter class constructor")
    }

    class Inner {
        constructor() {
            println("Inner class constructor")
        }
        fun doStuff(){
            println("Inner doStuff")
        }
    }

    fun createInner() {
        var inner = Inner()
        inner.doStuff()
    }
}


fun main() {
    var outter = Outer()
    outter.createInner()
}


2.Using outer class directly.
//class outer
class Outer {
    constructor() {
        println("Outter class constructor")
    }

    class Inner {
        constructor() {
            println("Inner class constructor")
        }

        fun doStuff() {
            println("Inner doStuff")
        }
    }

    fun createInner() {
        var inner = Inner()
        inner.doStuff()
    }
}


fun main() {
    var outter = Outer()
    outter.createInner()

    //access inner classes via outter class
    var outertwo = Outer.Inner()
    outertwo.doStuff()

    //calling methods directly using outer and inner instance
    Outer.Inner().doStuff()
}
.....................................................................................

Can Inner class access outter class members?

class OutterFoo {
    var myvar: Int? = 10

    class Bar {
        fun bar() = myvar
    }
}
You will get compile time error "Unresolved reference: myvar"

in order to access outter class variables , nested classes must be marked with keyword called "inner" infront of class 

class OutterFoo {
    var myvar: Int? = 10

    inner class Bar {
        fun bar() = myvar
    }
}

fun main() {
    print(OutterFoo().Bar().bar())
}
.....................................................................................
Anonymous Inner classes: to be discussed later

.....................................................................................
			   Dynamic Programming
.....................................................................................
In java , if you declare methods inside class, only those methods only can be used after instance creation.

Util.java

public class Util {
   public void add(){}
}
Util util=new Util()
util.add()

Here apart from add method we cant use other methods meaning that you cant insert methods dynamically after object creation.

Some languages(js,groovy,scala) offers  a feature to add/insert methods dynamically/during runtime without explcitily declaring inside class - "Dynamic programming"

Kotlin provides the ability to extend(adding) a class or interface with new functionality with out having to inherit or use any design patterns like "Decorator"

This is done via special declartions called "extensions"

Where this feature is usefull?

For eg, you can write new functions for a class or an interface from a third party lib that you cant modify.

Added functions to the lib, can be called in the usual way , as if they were methods of original class. This mechanism is called an "extension function".

Even you can also add new properties which is called "extension properties"


Extension function:
..................

In order to declare extension function, the prefix its name with a "Receiver Type".

Receiver Type:
 Which Referes to the type being extended.


fun ReciverType.method(args):Unit{

}


class Utility {
    //member function
    fun sayHello(): String {
        return "MemberFunction"
    }
}

//Extensions
fun Utility.sayHai(): String {
    return "Extension Function"
}


fun main() {
    var utility = Utility()
    println(utility.sayHello())
    println(utility.sayHai())

}
....................................................................................
			Can we extend any built in classes?

Yes, if you look at java, String final class, meaning that you cant extend(inherit) the class, so you cant have any your own string apis.

But in Kotlin you can, thats where Extension functions comes into Picture
class Utility {
    //member function
    fun sayHello(): String {
        return "MemberFunction"
    }
}

//Extensions
fun Utility.sayHai(): String {
    return "Extension Function"
}

//Extensions with String object
fun String.concat(): String {
    return "concat";
}


fun main() {
    var utility = Utility()
    println(utility.sayHello())
    println(utility.sayHai())
    var message: String = "hello"
    println(message.concat())
}
.....................................................................................
			 Receiver Type -Advanced
.....................................................................................

// ReceiverType.function; String
fun String.concat(s1: String): String {
    //How to refer receiver Type(Object) and its properties?
    //there is keyword called this keyword - this keyword is used to refer "Receiver" Object
    return "$s1 $this"
}

fun main() {
    var str1 = "Hello"
    var str2 = "Subramanian";
    println(str2.concat(str1)) //Hello Subramaian
}
.....................................................................................
Buitlin Extensions lot of functions are available in the core language

Int -  plus,div,minus etc..

Even we can write own functions

fun Int.add(another: Int): Int {
    return this.plus(another)
}

fun Int.multiply(another: Int): Int {
    return this * another
}

fun main() {
    var one = 10
    var two = 2
    var res = one.plus(two)
    println(res)
    println(one.add(two))
    println(one.multiply(two))

}
.....................................................................................
			   Extension Properties
.....................................................................................
class MyUtil {

}

//Extension Properties
val MyUtil.greetings: String
    get() = "Hello"

val String.hello: String
    get() = "Hello"

fun main() {
    var myUtil = MyUtil()
    println(myUtil.greetings)
    var str:String = ""
    println(str.hello)
}
....................................................................................
				Infix function
.....................................................................................
What is infix function?

Functions are marked with "infix" keyword are called infix functions.
infix functions are used to create DSL based code, we can omit the parentheses.

class A {
  infix fun doStuff(x:Type){}
}
var a = A()
a.doStuff(value)
a.doStuff 10
a doStuff 10

"hello" indexof 1 == > "hello".indexof(1)

Rules:
1.It must be class member functions or it can be extension function
2.They must have single parameter
3.The arg must not accept variable number of args(var args) and must have no default value.

class MyInfix {
    infix fun sayHello(name: String): Unit {
        println(name.uppercase())
    }
}

//extension function
infix fun MyInfix.sayHai(name: String) {
    println(name.uppercase())
}

infix fun Int.myAdd(another: Int) {
    println(this.add(another))
}

fun main() {
    var myInfix = MyInfix()
    //regular call
    myInfix.sayHello("Hello")
    //infix syntax
    myInfix sayHello "Hello"
    myInfix sayHai "subramanian"
    10 myAdd 100
}
.....................................................................................
			 inline functions
.....................................................................................

What is inline functions?


Generally functions are called from another functions, which creates separate stack framework.
some times it is more expensive cpu and memory
fun a(){
  b()
}
fun b() {
  //body 
}

We can use line functions not to create new stack framework, this feature is available in many languages like c,c++

inline:
  "By inserting the function code at the address of each function call , there by saving the overhead of a function call"

		"copy and paste function code of callee into calling place"

//caller
fun a(){
 //calling place
  b()
}
//callee
fun b() {
  //body 
}

Inlinining basically requesting the compiler to copy the (inlined) code at the calling place.

Why?
 Avoviding un neccessary stack framework creations, so that you can avoid tracking return address,args,values.

Kotlin and Inline Functions:
...........................	

In Kotlin, the higher order functions and lambdas are represented as "Object" behind the scene.

Since it is object takes some memory and increate the memory overhead if function gets called more no of times.

The use case might be the function does a very basic functionality that passing the control is not even worth as it is being used in multiple place, we need to create a separate function.

in order to reduce memory overhead of such functions we can use the "inline" keyword.

"inline" requests the CPU to not to allocate any memory for the functions and simply the copy body that function at the calling place.

fun sayGreet() {
    var counter = 1..100
    for (count in counter) {
        //sayHello(count)
        println(isEven(count))
    }
}

inline fun isEven(no: Int): Boolean {
    return no % 2 == 0
}

inline fun sayHello(count: Int) {
    println("Hello $count")
}


fun main() {
    sayGreet()
}
.....................................................................................
			Hierachy- Object relationship
.....................................................................................

There are two types hierachies:
1.HAS-A - composition
2.IS-A - Inheriance

Code Reuse Patterns:
1.Inheritance
2.Composition

IS-A: Inheritance:
.................

What is inheritance? Why inheritance?

Code Reuse, To avoid code duplication across the application, having common code that can be shared.


Inheritance Code Reuse Implmentations:
....................................
1.class-concrete class
2.interfaces
3.Abstract classes

Kotlin and inheritance:
......................
1.In kotlin all classes are freezed by default for extensions(inheritance)
   "Inheritance is disabled by default"
2.In Kotlin all classeses are "final classes" by default



class Base {
    
}
class Child: Base() {
    
}
Compile time Error: 
This type is final, so it cannot be inherited from


in order to allow any class to be inherited  it has to be marked as "open" keyword


open  class Base {

}
class Child: Base() {

}


fun main(){

}

...

Simple example:
open class Base {
    init {
        println("Base init is called")
    }
}

class Child : Base() {
    init {
        println("Child init is called")
    }
}


fun main() {
    var child = Child()
}
....................................................................................
			    Typing
.....................................................................................

How the reference variables are going to bind the expressions during compile time and runtime ?

var myref = Child()

Child myref =Child()

Polymorphsim:
..............
There are two types of polymorphism.
1.compile time
2.runtime 

Compile Time:
    The reference variable binds the properties and methods during compile time.
 This means the reference variables knows that in advance what are the methods are going to invoked.

var myref =Dog()
myref.bark() // binding

Run Time:
   The runtime calls the implementation code, the object 
 The Program to super type.

    "The reference variable type can be same type or its Parent type"


open class Animal {
    fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {

}

fun main() {
    //Program to Concretype
    var dog: Dog = Dog()
    println(dog.eat())
}

Output:
Animal eats

Here you can note down, there is no method implementation inside dog class but how we are getting output?


Source code:
open class Animal {
    fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {

}

After compilation: .class file

public class Animal {
    public String eat() {
        return "Animal eats"
    }
}

public class Dog extends Animal {
//it is copied by compiler
   public String eat() {
        return super.eat()
    }

}
Dog dog = new Dog()
dog.eat()
........................

How to reimplement eat method in the Dog class?

This is called as Overriding

In Kotlin all methods are by default "final" - cant be overriden

if you want to override the method, you have to open it.

In the dervied class, we need to use key word "override" 


open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    override fun eat(): String {
        return "Dog eats"
    }
}

fun main() {
    //Program to Concretype
    var dog: Dog = Dog()
    println(dog.eat())
}
.....................................................................................
			 Program To Super type
....................................................................................
open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    override fun eat(): String {
        return "Dog eats"
    }
}

fun main() {
    //Program to Super type
    var dog1: Animal = Dog()
    println(dog1.eat())

}
.....................................................................................
			Super Type and SubType
.....................................................................................open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    override fun eat(): String {
        return "Dog eats"
    }

    fun bark(): String {
        return "Dog barks"
    }
}

fun main() {
    //Program to Concretype
    var dog: Dog = Dog()
    println(dog.eat())

    //Program to Super type
    var dog1: Animal = Dog()
    println(dog1.eat())
    dog1.bark()

}
Compile time error for dog1.bark:

Why this error?

Rules:

1.During compile time the compiler always looks left side(Type) for method expression binding
 var dog1: Animal = Dog()
 dog1.bark()
Here type is Animal, now you can look at the compiler cant find "bark" method in the type called "Animal" so that compiler will give error.

2.During runtime the , The runtime looks always right Side(Instance) for method invocation(dynamic method dispatch /dynamic method invocation): Runtime polymorphism.
 
How to solve the compile time errors?
 How to invoke sub class(Dog) methods using Parent Type(animal)?

Solution is "Type Casting"
  We need to convert Animal type to Dog Type : Down casting (Super type down to Sub Type)

open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    override fun eat(): String {
        return "Dog eats"
    }

    fun bark(): String {
        return "Dog barks"
    }
}

fun main() {
    //Program to Concretype
    var dog: Dog = Dog()
    println(dog.eat())

    //Program to Super type
    var dog1: Animal = Dog()
    println(dog1.eat())
    //dog1.bark()
    //here we convert dog1 type(Animal) to Dog type
    var dog2: Dog = dog1 as Dog
    println(dog2.bark())

}

here "as" is type casting operator....
....................................................................................
			 How to over ride properties?
....................................................................................
open class Animal {
    open var category: String? = "Animal"
  
}

class Dog : Animal() {
    override var category: String? = "Dog"
  
}

fun main() {

    var dog1: Animal = Dog()

    println(dog1.category)
}
.....................................................................................
  	  How to call Super class Properties and methods
.....................................................................................
open class Account {
    open fun deposit(): Int {
        return 100
    }

    val accountType: String get() = "Account Type"
}

class SavingsAccount : Account() {
    override fun deposit(): Int {
        return super.deposit().plus(1000)
    }

    val accType: String get() = "${super.accountType} is Savings Account"

}

fun main() {
    var sb: Account = SavingsAccount()
    var sb1 = sb as SavingsAccount
    println("${sb.deposit()} ${sb1.accType}")
}
.....................................................................................
			Interfaces
....................................................................................

Interfaces are used to share code "Across the mutliple Hierachies" Where as the classes are used to share code only particular family type.

Class Based Hiearchy(Inheritance):
.................................
Single family

eg:
    Animal
     |
    eat
Dog
Cat
Tiger

Interface based Inheritance:
............................
Multiple family of classes

      Eatable
 	|
       eat
------------------------------
|       |     |     |     |
Animal Birds Humans Worms insects .....

interface Eatable {
    fun eat(): String
}

class Cat : Eatable {
    override fun eat(): String {
        return "Cat eats"
    }

    fun hunt() = "Hunt"
}

class Duck : Eatable {
    override fun eat(): String {
        return "Duck Eats"
    }

    fun swim() = "Swim"
}

fun main() {
    var myvar: Eatable? = null
    myvar = Cat()
    println(myvar.eat())
    //smart casting happens
    println(myvar.hunt())
    myvar = Duck()
    println(myvar.eat())
//    var myvar2 = myvar as Duck
//    println(myvar2.swim())

    //smart casting happens
    println(myvar.swim())

}

Notee:
 In the above code we have not done explicit casting in order to call implementation instance like swim and hunt methods

"Kotlin will take care of casting automatically which is called "Smart casting"

This is applicable only to interfaces
....................................................................................  
		 Multiple interfaces and inheritance
....................................................................................
interface Eat {
    fun eat(): String
}

interface Walk {
    fun walk(): String
}

interface Hunt {
    fun hunt(): String
}

class Tiger : Eat, Walk, Hunt {
    override fun eat(): String {
        return "eat"
    }

    override fun hunt(): String {
        return "hunt"

    }

    override fun walk(): String {
        return "walk"

    }
}

fun main() {
    var tiger = Tiger()
    println(tiger.eat())
    println(tiger.walk())
    println(tiger.hunt())

}
....................................................................................
		 Mutliple Interfaces and method Conflicts , How to solve them
....................................................................................


interface  Interface1 {
    fun doStuff():String
}

interface  Interface2 {
    fun doStuff():String
}
class Implementor: Interface1,Interface2 {
    override fun doStuff(): String {
        return  "DoStuff"
    }
}
fun main() {
    var implementor = Implementor()
    println(implementor.doStuff())
}
With respect to abstract methods, methods which has no implementation, we dont need to worry the which is over riden

....................................................................................
			 interfaces and implementations
.....................................................................................
Interfaces can have mulitple implementations too , what if method duplications?

"The Implementator class must provide default implementation and inisde that implementation we need to call method "super<interface1>.foo()"

interface Interface1 {
    fun doStuff(): String

    //implementation methods
    fun foo() {
        println("interface 1")
    }
}

interface Interface2 {
    fun doStuff(): String

    //implementation methods
    fun foo() {
        println("interface 2")
    }
}

class Implementor : Interface1, Interface2 {
    override fun doStuff(): String {
        return "DoStuff"
    }

    override fun foo() {
        super<Interface2>.foo()
    }
}

fun main() {
    var implementor = Implementor()
    println(implementor.doStuff())
    implementor.foo()
}
.....................................................................................
			Functional Interfaces - SAM (Single abstract method)
.......................................................................................

There are two implementations of SAM

1.java style
  -Using anonmous innter class pattern
2.Kotlin style
  - we have to declare with "fun" keyword

Inside interface if you declare methods, those methods are called as "abstract methods"

interface MyInterface { 
    fun myapi():String
}

Abstract methods are methods without implementations.

if an interface having single abstract method,that interface is called "SAM" - single abstract method.


The below interface cant be called as "Functional /SAM" interface

interface MyInterface { 
    fun myapi():String
    fun sayHello():String
}

SAM interfaces are used inside lambda expressions.

if you want to implement interface , you need class, using functional interfaces you dont need to provide a separate class rather we use "object" anonmous inner class.

Kotlin style :
interfaces must be marked with keyword called "fun"
if no fun keyword, it looks like java style.

//this interface having only one abstract methods
fun interface Greeter {
    //abstract fun greet(): Unit
    //by default all methods within interface is abstract, no need of using abstract keyword.
    fun greet(): Unit
}
//this interface having only one abstract methods
fun interface Greeter {
    //abstract fun greet(): Unit
    //by default all methods within interface is abstract, no need of using abstract keyword.
    fun greet(): Unit
}

fun interface Hello {
    fun sayHello(): Unit
}

//how to implement interface
//way 1 : using class implementation
class GreeterImpl : Greeter {
    override fun greet() {
        println("Greet")
    }
}


fun main() {
    var greeter = GreeterImpl()
    greeter.greet()
    //way 2 : anonymous inner class syntax: without class implementation .
    var mygreet = object : Greeter {
        override fun greet() {
            println("Anonymous Inner class")
        }
    }
    mygreet.greet()
    var mygreet1 = Greeter {
        println("Anonymous Inner class")
    }
    mygreet1.greet()
    //Refactored Code Lambda Expression syntax: but the interface must be marked with fun keyword
    var hello = Hello {
        println("Hello Lambda version")
    }
    hello.sayHello()
    //short cut 
    Hello {
        println("Hello simplified lambda")
    }.sayHello()

}
....................................................................................
		   Abstract classes = interface + concrete class 
....................................................................................

Abstract class and Non Abstract methods and abstract properties.

import kotlin.math.cbrt

abstract class Bird {
    //abstract method
    abstract fun fly(): Unit

    //non abstract method
    fun saveBirds() {
        println("Save Birds from hunters and Global warming")
    }
}

//
class Sparrow : Bird() {
    override fun fly() {
        println("Sparrow flys")
    }
}

class Eagle : Bird() {
    override fun fly() {
        println("Eagle flys at high")
    }
}


fun main() {
    var bird: Bird = Sparrow()
    bird.fly()
    bird.saveBirds()
    bird = Eagle()
    bird.fly()
    bird.saveBirds()
}
....................................................................................
				Has-a :Composition
....................................................................................
Composition:
 Object Linking


class Address(var street: String = "street", var city: String = "City") {}

//Here client has a Address
class Client(var id: Int = 0, var name: String = "Name", var address: Address = Address()) {}

fun main() {
    var client = Client(
        id = 1,
        name = "Subramanian",
        address = Address(
            street = "10th Street",
            city = "Coimbatore"
        )
    )
    println("${client.id} ${client.name} ${client.address.city} ${client.address.street} ")
}
.....................................................................................
			 Encaspulation
.....................................................................................

How to share and how to restric code from one class and one package to class and another package.

Visibility Modifiers:
 are used to restrict code sharing...

What can be code?
  code can be "class objects,interfaces,constructors,functions,properties and its setters and getters"

Keywords
1.private
2.protected
3.internal
4.public 

The default is public.

Scope:
1.file scope
  any thing you declare part file is called file scope
eg:
 Hello.kt

2.class scope
 any thing you declare with in class
eg:
 class Myclass{

 }
3.module scope
 any thing you declare with in the module(package)
 package com.ibm.myapp


1.file scope:
  you can declare variables,functions,classes,interfaces etc....

variables and functions can be marked private,public,internal

"private" means which is not available outside "file"

"public" means which is allowed outside "file" and across applications.

"internal" means which is allowed outside "file" but it should be part of "that module/package

eg:
private var foo: Int = 10

//public var bar: String = "20"
//public by default
var bar: String = "20"
internal var b: String = "223"


//functions with access modifer
//fun myFun() {
//    println("public fun")
//}
//Global Functions
public fun myFun() {
    println("public fun")
}

private fun getPassword() {
    println("Password ")
}

//Specific to Module
internal fun myInternal() {
    println("Global function")
}

//classes
//public class MyDemoClass {
//
//}

//Global Class
class MyDemoClass {

}

//private class is allowed, it is part of another internal kotlin class: so it is considered as
//inner class
private class MyDemoClassOne {

}

//Specific to module
internal class MyInternalClass {

}

//Modifier 'protected' is not applicable to 'top level property without backing field or delegate'
//protected var a:Int =10
fun main() {
    println(foo)
    println(bar)
    println(b)
    myFun()
    getPassword()
    myInternal()
    MyDemoClassOne()
}
.....................................................................................
			 Modularity - Packages
.....................................................................................

How to organize the code?

In java echo system code is organized into folders and files at low level and into packages and subpackages at logical level.

When we organize the code, we have to define rules for how to share and how to restrict - Encapuslation.

Modularity :

package statement
class 
fun
variables
interfaces

What is naming standard for packages?

com.companyName.moduleName.subModule

org.organization.module.submodule

DNS naming standards.

eg:
 package com.google.android
 package android.core.lib;


Types of packages:
1.custom package
2.built in packages
3.third party package.

Built in packages for kotlin.

package kotlin
  This is core package which is qu in java , java.lang.

package kotlin.collections
   which offers data structures used by languge

package kotlin.concurrent
  Basic threading functionlity

package kotlin.coroutines
 Async Programming features

package kotlin.io
  io apis for reading,writing data from and to files and streams.
.....................................................................................
			core package kotlin features


Any:
  It is root of every Kotlin class.
  In Java the root class is "Java.lang.Object"


class Money{
    
}
What is super class of this Kotlin class "Any"

open class Any { 

}

class Money:Any{
    
}
This class offers lot of methods which will be availble to all subclasses

This class offers:
1.equals
2.hashcode
3.toString

toString
  Returns the String Representation of object. By defualt "Any" class has logic like below.
class Money {

}

fun main() {
    var money = Money()
    println(money.toString())
}

Money@6d311334

Hascode representation of toString.

Overriding toString method:
..........................
class Money {
    var curreny: String? = "INR"

    override fun toString(): String {
        return "Currency [$curreny]"
    }
}

fun main() {
    var money = Money()
    println(money.toString())
}
............
equals Method:
..............
Comparing two objects says that whether objects are equal or not.




class Square(val side: Int) {

}

fun main() {
    var square1 = Square(10)
    var square2 = Square(10)
    var isEqual = square1.equals(square2)
    println(isEqual)
}
Output:
false

How equals methods returns false?
 "Any" class has method which always returns false

in order to compare objects, we need to override equals method.

Object equality is done via "Comparing Object properties only"
for eg:
 In Employee, each Employee is indefined by EmployeeId

if two objects employeeId is same, Objects are same or Objects different


In order to equalize kotlin offers three patterns

1.using equals method
2.using == operator
  =>compares based on properties
3.using === operator  
  =>compares based on memory address



class Square(val side: Int) {

    override fun equals(other: Any?): Boolean {
        //Test whether other variables is same as Square type: in java we use "instanceOf"
        //operator : in Kotlin we use "is" operator
        if (other is Square) {
            return other.side == side
        }
        return false
    }
}

fun main() {
    var square1 = Square(10)
    var square2 = Square(10)
    var square3 = square2 // square3 and square2 points the same object

    //using equals method
    var isEqual = square1.equals(square2)
    var res = if (isEqual) "Two Squares are equal" else "two squares are not equal"
    println(res)
    //using equals operator :Compares based on property
    isEqual = square1 == square2
    res = if (isEqual) "Two Squares are equal" else "two squares are not equal"
    println(res)

    //using triple equals operator compares based on memory location
    isEqual = square3 === square2
    res = if (isEqual) "Two Squares are equal" else "two squares are not equal"
    println(res)
}

== "Structural Equality" -Object property verification
=== "Referential Equality" - Object Memory location verification.
.....................................................................................

hashcode:
 It is unquie no generated by JVM and attached to every instance , which we create, in order to identify the objects.

class Square(val side: Int) {

    override fun hashCode(): Int {
        return 23232323
    }
}

fun main() {
    var square1 = Square(10)

    println(square1.hashCode())
}
.....................................................................................
		What if i want all methods of "Any" class override in sub class"
			

What if i want 

->hashcode
->toString
->equals 
method in a class

"Data Class":
..............
=>It is sole purpose is as name indicates which holds data.
=>Data classes can hold standard functionality and some utiltiy functions such as "tostring hashcode,equals,clone apis"


//data class Product(val id: Int, val name: String, val price: Double){}
data class Product(val id: Int, val name: String, val price: Double)

fun main() {
    var product1 = Product(1, "IPHONE 15", 135000.00)
    var product2 = Product(2, "IPHONE 15", 135000.00)
    println(product1.toString())
    println(product1.hashCode())
    println(product1 == product2)
    var product3 = product2.copy(id = 3, name = "IPHONE I5 Pro")
    println(product3.toString())

}
.................................................................................
			Custom Packages
.................................................................................

creating our own packages

package com.ibm.kotlin.oo

data class User(val id: Int, val name: String)

val message: String = "USER APP"
fun save() {
    println("Save")
}



package com.ibm.kotlin.oo.main

import com.ibm.kotlin.oo.User
import com.ibm.kotlin.oo.message
import com.ibm.kotlin.oo.save

fun main() {
    val user = User(id = 1, name = "Subrmanian")
    println(user.toString())
    save()
    println(message)
}

=> to declare package we use package statement
=> to link classes from different packages we use import 
.....................................................................................
		 DeStructuring Object Properties
.....................................................................................

package com.ibm.kotlin.oo.destructruing

data class User(val id: Int, var name: String, var city: String)


package com.ibm.kotlin.oo.destructruing

fun main() {
    var user = User(id = 1, name = "Subramanian", city = "Coimbatore")
    //property access without Destructuring
    println("${user.id} ${user.name} ${user.city}")
    //With DeStructuring
    var (id, name, city) = User(id = 1, name = "Subramanian", city = "Coimbatore")
    println("$id $name $city")

}
.....................................................................................
			Sealed Classes
.....................................................................................

Sealed classes and interfaces represented "restricted" class hiearchy that provide more control over inheritance.

All Direct subclasses of a sealed class are known at compile time.

No other subclasses may appear outside a module within which the sealed classes is defined.

Sealed classes are abstract by default, so cant be instantiated.

package com.ibm.kotlin.oo.sealedclasses

sealed class MyResult {
    //INNER Classes
    data class Success(val resolve: String) : MyResult()
    data class Failure(val reject: String) : MyResult()
    data class Loader(val loading: String) : MyResult()
}

fun getSuccess(): MyResult {
    return MyResult.Success("Success")

}

fun getFailure(): MyResult {
    return MyResult.Failure("Failed")
}

fun getResponse(status: Int = 200): MyResult {
    if (status == 200) return MyResult.Success("Response found")
    return MyResult.Failure("Response Not found")
}

fun main() {
    var status = getSuccess()
    when (status) {
        is MyResult.Success -> {
            println(status.resolve)
        }
        is MyResult.Failure -> {
            println(status.reject)
        }
        else -> {
            println("Loading...")
        }
    }
    status = getFailure()
    when (status) {
        is MyResult.Success -> {
            println(status.resolve)
        }
        is MyResult.Failure -> {
            println(status.reject)
        }
        else -> {
            println("Loading...")
        }

    }
    status = getResponse(500)
    when (status) {
        is MyResult.Success -> {
            println(status.resolve)
        }
        is MyResult.Failure -> {
            println(status.reject)
        }
        else -> {
            println("Loading...")
        }

    }
}
...................................................................................
				Enum -  class
..................................................................................

In order to represent "Named Constants" enums are used.
package com.ibm.kotlin.oo.enums

//Enum declartions
enum class Color {
    //RED=0,BLUE=1,GREEN=2
    RED, BLUE, GREEN
}
enum class Positions {
    NORTH,EAST,WEST,SOUTH
}

fun main() {
  println("Value ${Color.RED.ordinal} Name ${Color.RED.name}")

}
..................................................................................
			 Enum Initalizers
.................................................................................

package com.ibm.kotlin.oo.enums

enum class Day(val day: Int) {
    MONDAY(1),
    TUESDAY(2),
    WEDNESDAY(3),
    THURSDAY(4),
    FRIDAY(5),
    SATURDAY(6),
    SUNDAY(7)
}


fun main(){
    println("Value ${Day.MONDAY.day} ${Day.MONDAY.name}")
}
.....................................................................................
			 Methods inside Enum
....................................................................................
package com.ibm.kotlin.oo.enums

enum class Day(val day: Int) {
    MONDAY(1),
    TUESDAY(2),
    WEDNESDAY(3),
    THURSDAY(4),
    FRIDAY(5),
    SATURDAY(6),
    SUNDAY(7);

    //methods
    fun getDayOfWeek(): String {
        return "[${SUNDAY}] IS Holiday"
    }
}


fun main() {
    println("Value ${Day.MONDAY.day} ${Day.MONDAY.name}")
    println("${Day.SUNDAY.getDayOfWeek()}")
}
.....................................................................................
			Companion Objects
....................................................................................

1.If you want to create Single ton,In java you have to write logic your self.
2.Companion objects are used to create instance of class using factory methods.
3.Companions are used to delclare static members in kotlin because kotlin does not support "static keyword"

Properties of the "Object class" if you want to access, you have to use Notations like like.

The below code is not singleton

package com.ibm.kotlin.oo.companions

class Greetings {
    object Factory {
        fun createInstance(): Greetings = Greetings()
    }
}

fun main() {
    println(Greetings.Factory.createInstance().hashCode())
    println(Greetings.Factory.createInstance().hashCode())

}

Static Version
package com.ibm.kotlin.oo.companions

class Welcome {

    //companion is used to declare static memebers
    companion object {
        //act as static methods, in Kotlin there is no static keyword
        fun createInstance(): Welcome = Welcome()
        var MESSAGE = "HELLO"
        var INFO = "INFO"
    }

    fun sayHello() = "Welcome"
}

fun main() {
    var welcome = Welcome.createInstance()
    println(welcome.sayHello())
    println(Welcome.MESSAGE)
    println(Welcome.INFO)

}
...................................................................................
			 Scope Functions
...................................................................................

Scope functions are built in kotlin standard lib functions like toString,hashcode,equals.

Scope functions primary purpose is to execute a block of code(lambda) within the context of an object.

"Scope" means when you call scope functions on an object with a lambda expressions provided, it forms temporary scope, you can access the properties without its name.


There are five scope functions:
...............................

1.let
2.run 
3.with
4.apply
5.also

Scope functions simiplify the object property access.

Without scope functions how to access Object properties:
package com.ibm.kotlin.oo.scopefunctions


data class User(var name: String, var location: String, var points: Int) {
    //biz methods
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }

}

fun main() {
    var user = User(name = "Subramanian", location = "Coimbatore", points = 100)
    //access the properties of object
    println("Location ${user.location}")
    println("Name${user.name}")
    println("Points ${user.points}")
    user.updateLocation("Chennai")
    user.incrementPoints()
    println("Name${user.name}")
    println("Points ${user.points}")
}
Here we have accessed properties using reference variables
...........................
How to access the properties with scope functions:


Scope functions and its difference

.................................................................................
Function Name         Object Reference    Return Value  isExtension Function.
 let                   it                 Lambda         Yes
 run                   this               Lambda         Yes
 with                  this               Lambda         No
 apply                 this               Object         Yes
 also                  it                 Object         Yes
...................................................................................

Function Name says that name of the scope function
Object Reference says that how object properties are accesed inside scope lambda(this or it)
Return value of the scope functions could be object itself(this), lambda expression.


package com.ibm.kotlin.oo.scopefunctions


data class User(var name: String, var location: String, var points: Int) {
    //biz methods
    fun updateLocation(newLocation: String) {
        location = newLocation
    }

    fun incrementPoints() {
        points++
    }

}

fun main() {
    var user = User(name = "Subramanian", location = "Coimbatore", points = 100)
    //access the properties of object using reference value
    println("Location ${user.location}")
    println("Name${user.name}")
    println("Points ${user.points}")
    user.updateLocation("Chennai")
    user.incrementPoints()
    println("Name${user.name}")
    println("Points ${user.points}")
    // Using let keyword
    User(name = "Subramanian", location = "Coimbatore", points = 100).let {
        //scope
        println("Location ${it.location}")
        println("Name${it.name}")
        println("Points ${it.points}")
        //return value
        it
    }.let {
        it.updateLocation("Chennai")
        it.incrementPoints()
        it
    }.let {
        println("Name${user.name}")
        println("Points ${user.points}")
    }
    "hello".let {
        it.uppercase()
        it
    }.let {
        println(it)
    }

    //using run method
    User(name = "Subramanian", location = "Coimbatore", points = 100).run {
        //scope
        println("Location ${this.location}")
        println("Name${this.name}")
        println("Points ${this.points}")
        //return value
        this
    }.run {
        this.updateLocation("Chennai")
        this.incrementPoints()
        this
    }.run {
        println("Name${this.name}")
        println("Points ${this.points}")
    }

    //using with method
    var myUser = User(name = "Subramanian", location = "Coimbatore", points = 100)

    println("With ")
    with(myUser.run {
        println("Location ${location}")
        println("Name${name}")
        println("Points ${points}")
        this
    }) {
        updateLocation("Chennai")
        incrementPoints()
        println("Name${name}")
        println("Points ${points}")
        this
    }
    with("subramanian".run {
        println("upper" + uppercase())
        trim()
        println(this)
        this
    }) {
        println("length " + this.length)
    }

    println("Apply function...")
    //apply
    User(name = "Subramanian", location = "Coimbatore", points = 100).apply {
        println(this.name + " " + name)
        println(location)
        println(points)
        name = "Murugan"
        updateLocation("US")
        incrementPoints()
        this
    }.apply {
        println(name)
        println(location)
        println(points)
    }
    //also
    println("also function...")
    User(name = "Subramanian", location = "Coimbatore", points = 100).also {
        println(it.name)
        println(it.location)
        //you dont need to return this manually : implicit this
    }.apply {
        println(name)
        println(location)
        println(points)
    }


}

....................................................................................
			  Operator Overloading
....................................................................................
operator overloding means we can use existing operators for different purposes let say
 + operator is used to arthmetic operations
  10 + 10 => 20  Numerical compuations
 + operator is used for concat two strings. string with any other values

 "hello" + "world" => "hello world" - concatnation

Operator overloading is not permitted in java but kotlin offers operator overloading feature in kotlin

Kotlin offers operator overloading via "operator" key word with functions

Operator functions can be member function of object or extension function .


package com.ibm.kotlin.oo.operatoroverloading

class Person {
    var skills: String? = null
    fun show() = skills
}

operator infix fun Person.plus(person: Person): Person {
    var newPerson = Person()
    newPerson.skills = this.skills + person.skills
    return newPerson
}


fun main() {
    var person1 = Person()
    person1.skills = "Kotlin"
    println(person1.show())
    var person2 = Person()
    person2.skills = "Mobile Developement"
    println(person2.show())

    //Coimbine two person skills via operator
    //var newSkill = person1.plus(person2)
//    var newSkill = person1 + person2
    var newSkill = person1 plus person2
    newSkill.apply {
        println(show())
    }
    //Builtin operator over loaded apis
    var a: Int = 100
    var b: Int = 200
    //without operator overloading
    var c: Int? = null
    c = a + b
    println(c)
    //with operator overloading
    c = a.plus(b)
    println(c) 

}
...................................................................................
			 Generics and Collections - Data Structures
...................................................................................
Why Generics?
 Type safty 


package com.ibm.kotlin.collections

data class Customer(val id: Int = 1, val name: String = "")
data class Employee(val id: Int = 1, val name: String = "")

interface CustomerRepository {
    val isEmpty: Boolean get() = true
    fun store(obj: Customer) {
        //implement code how to store
    }

    fun getById(id: Int): Customer
}

interface EmployeeReposiotry {
    val isEmpty: Boolean get() = true
    fun store(obj: Employee) {
        //implement code how to store
    }

    fun getById(id: Int): Employee
}

//implementation classes
class CustomerRepsitoryImpl : CustomerRepository {
    override fun getById(id: Int): Customer {
        TODO("Not yet implemented")
    }

    override val isEmpty: Boolean
        get() = super.isEmpty

    override fun store(obj: Customer) {
        super.store(obj)
    }
}

class EmployeeRepsitoryImpl : EmployeeReposiotry {
    override fun getById(id: Int): Employee {
        TODO("Not yet implemented")
    }

    override val isEmpty: Boolean
        get() = super.isEmpty

    override fun store(obj: Employee) {
        super.store(obj)
    }
}

fun main() {
    var customerRepository = CustomerRepsitoryImpl()
    println(customerRepository.isEmpty)
    var employeeReposiotry = EmployeeRepsitoryImpl()
    println(employeeReposiotry.isEmpty)
}

In the above code the interface remains same across multiple repositories...

where code is duplicated.

How to avoid code duplication?

We can have common interface and implmentation class, based on our Type like Customer,Employee....

We need kind of "Common Interface and common class"  - Generics(common).


What is Generics?
  Generics means Parametermized types.
 The idea is to allow types(Integer,Double,String,Employee) on fly.

In java : you may be thinking programm to super type.

Object o = new String()
Object o =new Customer()

In Kotlin:

var o:Any = String()
var o:Any = Customer()
Any o:Any = Repository()

When we use Program to super type, some times it would be problem

1.Casting issues
2.Lack of Type Safety

Where we can apply generics?

1.class or interface level
  You can create type safe container objects by declaring classes

2.function level
  You can apply type safe functions - generic functions

Generics Syntax:
 <T>  - Symbol is used to denote type.


Generic interface and Generic class:
package com.ibm.kotlin.collections.generics

data class Customer(val id: Int = 1, val name: String = "Subramanian")
data class Employee(val id: Int = 1, val name: String = "")

interface Repository<T> {
    fun getById(id: Int): T
    fun getAll(): List<T>
}

class RespositoryImpl<T> : Repository<T> {
    override fun getAll(): List<T> {
        TODO("Not yet implemented")
    }

    override fun getById(id: Int): T {
        TODO("Not yet implemented")
    }
}

fun main() {
    //customer Object
    var customers = RespositoryImpl<Customer>()
    customers.getAll()
    customers.getById(1)
    var employees = RespositoryImpl<Employee>()
    employees.getById(3)
    employees.getAll()
}

Generic functions

package com.ibm.kotlin.collections.generics

data class Customer(val id: Int = 1, val name: String = "Subramanian")
data class Employee(val id: Int = 1, val name: String = "")

interface Repository<T> {
    fun <T> getById(id: Int): T
    fun <E> getAll(): List<T>
}

class RespositoryImpl<T> : Repository<T> {
    override fun <E> getAll(): List<T> {
        TODO("Not yet implemented")
    }

    override fun <T> getById(id: Int): T {
        TODO("Not yet implemented")
    }
}

fun main() {
    //customer Object
    var customers = RespositoryImpl<Customer>()
    customers.getAll<Employee>()
    customers.getById<Employee>(1)
    var employees = RespositoryImpl<Employee>()
    employees.getById<Customer>(3)
    employees.getAll<Customer>()
}
...................................................................................
				Collections
...................................................................................

Kotlin and Data structure:
.........................

Kotlin supports multiple data structures like java.

Array
  It is fundamental data structure
  Array is object
  Array is fixed ds
  Array can accept any type of values

Kotlin and Arrays:

In Kotlin Array is Object represented by "Array" class
It has setters and getters- set and get functions
It has size property

Primitive Arrays:
IntArray
ShortArray
ByteArray

Array object creations:

1.using factory apis
  intArrayOf()

2.Using constructor functions
  Arg is capacity of array
  IntArray(10) or Array()


package com.ibm.kotlin.collections.arrays

fun main() {
    //factory api
    var myIntArray: IntArray = intArrayOf(1, 2, 3, 4, 5, 6, 7)
    println(myIntArray.get(0))
    //log all values
    myIntArray.iterator().forEach { println(it) }

    //not recommened
    //constructors
    var counters = IntArray(5)
    counters.set(0, 1)
    counters.set(1, 2)
    counters.forEach { println(it) }
    //Constructor
    var strArray = Array(3, { i -> "hello ${i}" })
    strArray.iterator().forEach { println(it) }

    //generic api
    arrayOf<String>("Kotlin","Java","Scala").let {
        it.forEach { println(it) }
    }
}
....................................................................................
			  Dynamic Array: Collections
....................................................................................

Kotlin Collections has been built on the top of java collections.

General Collection/ds

1.List
2.Set
3.Map

1.List:
   Ordered collection 
   with elements by index
   with elmenets by hashcode
   with insertion order.

2.Set 
   Collection 
     with unique elements- No duplicates
   order is dermined by natural order of the elements
  
3.Map
   set of key-value pairs
   keys are unique,each of them maps exactly one value.


Collections types:
1.readonly collection - Immutable collection
2.write only- Mutable collections

Mutable collections:List
package com.ibm.kotlin.collections

fun main() {
    var list = mutableListOf<Int>(1, 2, 3)
    list.forEach { println(it) }
    list.add(13)
    list.add(33)
    list.forEach { println(it) }
    //using scope functions
    mutableListOf<Int>(1, 2, 3).apply {
        add(33)
        add(34)
    }.apply {
        println("Before Sorting")
        forEach { println(it) }
    }.apply {
        sortByDescending { it }
    }.apply {
        println("After Sorting")
        forEach { println(it) }
    }

}

Mutable Collection: Set : No duplicates

package com.ibm.kotlin.collections

fun main() {
    mutableSetOf<Int>(1, 2, 3, 4, 5).apply {
        add(1)
        add(2)
        add(10)
        add(4)
    }.apply {
        forEach { println(it) }
    }
}












































































































































































































































